<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.4">
<title>User Guide</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
body{margin:0}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
body{-webkit-font-smoothing:antialiased}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
body{tab-size:4}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>User Guide</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#what-does-onyx-offer">What does Onyx offer?</a>
<ul class="sectlevel2">
<li><a href="#_an_information_model">An Information Model</a></li>
<li><a href="#_temporal_decoupling">Temporal Decoupling</a></li>
<li><a href="#_elimination_of_macros">Elimination of Macros</a></li>
<li><a href="#_plain_clojure_functions">Plain Clojure Functions</a></li>
<li><a href="#_testing_without_mocking">Testing Without Mocking</a></li>
<li><a href="#_easy_parameterization_of_workflows">Easy Parameterization of Workflows</a></li>
<li><a href="#_transparent_code_reuse_for_batch_and_streaming">Transparent Code Reuse for Batch and Streaming</a></li>
<li><a href="#_aspect_orientation">Aspect Orientation</a></li>
<li><a href="#_aot_nothing">AOT Nothing</a></li>
</ul>
</li>
<li><a href="#concepts">Concepts</a>
<ul class="sectlevel2">
<li><a href="#_terminology">Terminology</a></li>
</ul>
</li>
<li><a href="#low-level-design">Architecture &amp; Low Level Design</a>
<ul class="sectlevel2">
<li><a href="#_high_level_components">High Level Components</a></li>
<li><a href="#_applying_log_entries">Applying Log Entries</a></li>
<li><a href="#_joining_the_cluster">Joining the Cluster</a></li>
<li><a href="#_dead_peer_removal">Dead peer removal</a></li>
<li><a href="#_messaging">Messaging</a></li>
<li><a href="#_garbage_collection">Garbage collection</a></li>
<li><a href="#_command_reference">Command Reference</a></li>
</ul>
</li>
<li><a href="#_apis">APIs</a>
<ul class="sectlevel2">
<li><a href="#core-api">Core API</a></li>
<li><a href="#peer-pipeline-api">Peer Pipeline API</a></li>
</ul>
</li>
<li><a href="#functions">Functions</a>
<ul class="sectlevel2">
<li><a href="#_functional_transformation">Functional Transformation</a></li>
<li><a href="#_function_parameterization">Function Parameterization</a></li>
<li><a href="#_grouping_aggregation">Grouping &amp; Aggregation</a></li>
<li><a href="#_group_by_key">Group By Key</a></li>
<li><a href="#_group_by_function">Group By Function</a></li>
<li><a href="#_flux_policies">Flux Policies</a></li>
<li><a href="#_batch_functions">Batch Functions</a></li>
<li><a href="#_leaf_functions">Leaf Functions</a></li>
</ul>
</li>
<li><a href="#flow-conditions">Flow Conditions</a>
<ul class="sectlevel2">
<li><a href="#_summary">Summary</a></li>
<li><a href="#_motivating_example">Motivating Example</a></li>
<li><a href="#_predicate_function_signatures">Predicate Function Signatures</a></li>
<li><a href="#_predicate_parameters">Predicate Parameters</a></li>
<li><a href="#_key_exclusion">Key Exclusion</a></li>
<li><a href="#_predicate_composition">Predicate Composition</a></li>
<li><a href="#_match_all_none">Match All/None</a></li>
<li><a href="#_short_circuiting">Short Circuiting</a></li>
<li><a href="#_exceptions">Exceptions</a></li>
<li><a href="#_post_transform">Post-transform</a></li>
<li><a href="#_actions">Actions</a></li>
</ul>
</li>
<li><a href="#messaging">Messaging</a>
<ul class="sectlevel2">
<li><a href="#_background">Background</a></li>
<li><a href="#_messaging_implementations">Messaging Implementations</a></li>
</ul>
</li>
<li><a href="#lifecycles">Lifecycles</a>
<ul class="sectlevel2">
<li><a href="#_summary_2">Summary</a></li>
<li><a href="#_lifecycle_phases">Lifecycle Phases</a></li>
<li><a href="#_example">Example</a></li>
</ul>
</li>
<li><a href="#windowing-and-aggregation">Windowing and Aggregation</a>
<ul class="sectlevel2">
<li><a href="#_summary_3">Summary</a></li>
<li><a href="#_window_types">Window Types</a></li>
<li><a href="#_units">Units</a></li>
<li><a href="#_aggregation">Aggregation</a></li>
<li><a href="#_window_specification">Window Specification</a></li>
</ul>
</li>
<li><a href="#triggers">Triggers</a>
<ul class="sectlevel2">
<li><a href="#_summary_4">Summary</a></li>
<li><a href="#_trigger_types">Trigger Types</a></li>
<li><a href="#_refinement_modes">Refinement Modes</a></li>
<li><a href="#_syncing">Syncing</a></li>
<li><a href="#_trigger_specification">Trigger Specification</a></li>
</ul>
</li>
<li><a href="#aggregation-state-management">Aggregation &amp; State Management</a>
<ul class="sectlevel2">
<li><a href="#summary">Summary</a></li>
<li><a href="#state-example">State Example</a></li>
<li><a href="#fault-tolerance">Fault Tolerance</a></li>
<li><a href="#exactly-once-aggregation-updates">Exactly Once Aggregation Updates</a></li>
<li><a href="#considerations">Considerations</a></li>
<li><a href="#exactly-once-side-effects">Exactly Once Side-Effects</a></li>
<li><a href="#bookkeeper-implementation">BookKeeper Implementation</a></li>
<li><a href="#running-the-embedded-bookkeeper-server">Running the embedded BookKeeper server</a></li>
<li><a href="#state-log-compaction">State Log Compaction</a></li>
<li><a href="#bookkeeper-implementation-configuration">BookKeeper Implementation Configuration</a></li>
</ul>
</li>
<li><a href="#resume-point">Resume Points</a>
<ul class="sectlevel2">
<li><a href="#_motivation">Motivation</a></li>
<li><a href="#_resume_point_definition">Resume Point Definition</a></li>
<li><a href="#_resume_point_modes">Resume Point Modes</a></li>
<li><a href="#_resume_point_helpers">Resume Point Helpers</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<!-- toc disabled -->
</div>
</div>
<div class="sect1">
<h2 id="what-does-onyx-offer"><a class="anchor" href="#what-does-onyx-offer"></a>What does Onyx offer?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this chapter, I&#8217;ll enumerate and explain the reasons why we built
Onyx.</p>
</div>
<div class="sect2">
<h3 id="_an_information_model"><a class="anchor" href="#_an_information_model"></a>An Information Model</h3>
<div class="paragraph">
<p>Information models are often superior to APIs, and almost always better
than DSLs. The hyper-flexibility of a data structure literal allows Onyx
workflows and catalogs to be constructed <em>at a distance</em>, meaning on
another machine, in a different language, by another program, etc.</p>
</div>
<div class="paragraph">
<p>The information model for an Onyx workflow has the distinct advantage
that it&#8217;s possible to compile <em>other</em> workflow representations (perhaps
a datalog or SQL query) into the workflow that Onyx understands. The
<a href="#information-model">Information Model</a> chapter describes a target for data structure
compilation.</p>
</div>
</div>
<div class="sect2">
<h3 id="_temporal_decoupling"><a class="anchor" href="#_temporal_decoupling"></a>Temporal Decoupling</h3>
<div class="paragraph">
<p>To the extent that Onyx places data at the highest importance, very few
Onyx constructs actually need to be generated at the same time as
program deployment or peer registration. Programs can create workflows,
drop them to a database, and pull them out at a later time without any
problems.</p>
</div>
</div>
<div class="sect2">
<h3 id="_elimination_of_macros"><a class="anchor" href="#_elimination_of_macros"></a>Elimination of Macros</h3>
<div class="paragraph">
<p>Macros are a tremendously powerful tool, but are often inappropriate for
end-user consumption of an API. Onyx goes beyond Storm&#8217;s <code>defbolt</code> and
<code>defspout</code> by making vanilla Clojure functions shine. These functions
need no context to execute and do not require any dynamic bindings. They
receive <em>all</em> information that they need via parameters, which are
injected by Onyx&#8217;s task lifecycles.</p>
</div>
</div>
<div class="sect2">
<h3 id="_plain_clojure_functions"><a class="anchor" href="#_plain_clojure_functions"></a>Plain Clojure Functions</h3>
<div class="paragraph">
<p>To the same point above, we want plain Clojure functions to be the
building blocks for application logic. Onyx&#8217;s functions can be tested
directly without any special test runner.</p>
</div>
</div>
<div class="sect2">
<h3 id="_testing_without_mocking"><a class="anchor" href="#_testing_without_mocking"></a>Testing Without Mocking</h3>
<div class="paragraph">
<p>In general, your design is in trouble when you&#8217;ve reached for
<code>with-redefs</code> or something along those lines to mock functions. Onyx
places a high importance around programming against interfaces, and even
more-so around putting space in-between small components with channels.
Onyx programs can be tested in development mode, and moved to production
mode with only a small configuration file change. If you&#8217;d like to
change your input or output plugins, all you need to do is re-associate
the catalog entry with something like an in-memory plugin. No interface
mocking code required.</p>
</div>
</div>
<div class="sect2">
<h3 id="_easy_parameterization_of_workflows"><a class="anchor" href="#_easy_parameterization_of_workflows"></a>Easy Parameterization of Workflows</h3>
<div class="paragraph">
<p>It&#8217;s particularly telling that many compute frameworks don&#8217;t offer an
easy way to parameterize workflows. Onyx puts space between the caller
and the function definition. Parameterize tasks inside the catalog, and
update the catalog entry at will. Additionally, Onyx allows peers to
spin up their own parameters at boot-up time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_transparent_code_reuse_for_batch_and_streaming"><a class="anchor" href="#_transparent_code_reuse_for_batch_and_streaming"></a>Transparent Code Reuse for Batch and Streaming</h3>
<div class="paragraph">
<p>Onyx uses the notion of a <em>sentinel value</em> to transparently switch
between streaming and batching modes. This makes it really easy to be
able to reuse the same code for both batch and streaming computations.</p>
</div>
</div>
<div class="sect2">
<h3 id="_aspect_orientation"><a class="anchor" href="#_aspect_orientation"></a>Aspect Orientation</h3>
<div class="paragraph">
<p>Clojure functions again serve as a huge win.
<a href="https://github.com/MichaelDrogalis/dire">Dire</a> is a library that supports
aspects, meaning you can keep your application logic airtight away from
logging, preconditions, and error handling.</p>
</div>
</div>
<div class="sect2">
<h3 id="_aot_nothing"><a class="anchor" href="#_aot_nothing"></a>AOT Nothing</h3>
<div class="paragraph">
<p>Onyx AOT&#8217;s absolutely nothing on your behalf. When you&#8217;re ready to stand
your jar up, simply uberjar and start executing on the target machine.
Hadoop and Storm cause dependency hell (In Storm&#8217;s case, you&#8217;re
restricted to a particular version of Clojure because you&#8217;re locked in
by the Executor) by providing their own dependencies on top of yours.
Onyx won&#8217;t mess with your dependencies.</p>
</div>
<div class="paragraph">
<p>You can, however, AOT Onyx yourself to speed up compilation times.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="concepts"><a class="anchor" href="#concepts"></a>Concepts</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We&#8217;ll take a quick overview of some terms you&#8217;ll see in the rest of this
user guide.</p>
</div>
<div class="sect2">
<h3 id="_terminology"><a class="anchor" href="#_terminology"></a>Terminology</h3>
<div class="sect3">
<h4 id="_segment"><a class="anchor" href="#_segment"></a>Segment</h4>
<div class="paragraph">
<p>A segment is the unit of data in Onyx, and it&#8217;s represented by a Clojure
map. Segments represent the data flowing through the cluster. Segments
are the only shape of data that Onyx allows you to emit between
functions.</p>
</div>
</div>
<div class="sect3">
<h4 id="_task"><a class="anchor" href="#_task"></a>Task</h4>
<div class="paragraph">
<p>A task is the smallest unit of work in Onyx. It represents an activity
of either input, processing, or output.</p>
</div>
</div>
<div class="sect3">
<h4 id="_workflow"><a class="anchor" href="#_workflow"></a>Workflow</h4>
<div class="paragraph">
<p>A workflow is the structural specification of an Onyx program. Its
purpose is to articulate the paths that data flows through the cluster
at runtime. It is specified via a directed, acyclic graph.</p>
</div>
<div class="paragraph">
<p>The workflow representation is a Clojure vector of vectors. Each inner
vector contains exactly two elements, which are keywords. The keywords
represent nodes in the graph, and the vector represents a directed edge
from the first node to the second.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">;;;    in</span>
<span class="comment">;;;    |</span>
<span class="comment">;;; increment</span>
<span class="comment">;;;    |</span>
<span class="comment">;;;  output</span>
[[<span class="symbol">:in</span> <span class="symbol">:increment</span>] [<span class="symbol">:increment</span> <span class="symbol">:out</span>]]</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">;;;            input</span>
<span class="comment">;;;             /\</span>
<span class="comment">;;; processing-1 processing-2</span>
<span class="comment">;;;     |             |</span>
<span class="comment">;;;  output-1      output-2</span>

[[<span class="symbol">:input</span> <span class="symbol">:processing-1</span>]
 [<span class="symbol">:input</span> <span class="symbol">:processing-2</span>]
 [<span class="symbol">:processing-1</span> <span class="symbol">:output-1</span>]
 [<span class="symbol">:processing-2</span> <span class="symbol">:output-2</span>]]</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">;;;            input</span>
<span class="comment">;;;             /\</span>
<span class="comment">;;; processing-1 processing-2</span>
<span class="comment">;;;         \      /</span>
<span class="comment">;;;          output</span>

[[<span class="symbol">:input</span> <span class="symbol">:processing-1</span>]
 [<span class="symbol">:input</span> <span class="symbol">:processing-2</span>]
 [<span class="symbol">:processing-1</span> <span class="symbol">:output</span>]
 [<span class="symbol">:processing-2</span> <span class="symbol">:output</span>]]</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Example projects:
<a href="https://github.com/onyx-platform/onyx-examples/tree/0.9.x/flat-workflow">flat-workflow</a>,
<a href="https://github.com/onyx-platform/onyx-examples/tree/0.9.x/multi-output-workflow">multi-output-workflow</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_catalog"><a class="anchor" href="#_catalog"></a>Catalog</h4>
<div class="paragraph">
<p>All inputs, outputs, and functions in a workflow must be described via a
catalog. A catalog is a vector of maps, strikingly similar to Datomic’s
schema. Configuration and docstrings are described in the catalog.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[{<span class="symbol">:onyx/name</span> <span class="symbol">:in</span>
  <span class="symbol">:onyx/plugin</span> <span class="symbol">:onyx.plugin.core-async/input</span>
  <span class="symbol">:onyx/type</span> <span class="symbol">:input</span>
  <span class="symbol">:onyx/medium</span> <span class="symbol">:core.async</span>
  <span class="symbol">:onyx/batch-size</span> batch-size
  <span class="symbol">:onyx/max-peers</span> <span class="integer">1</span>
  <span class="symbol">:onyx/doc</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Reads segments from a core.async channel</span><span class="delimiter">&quot;</span></span>}

 {<span class="symbol">:onyx/name</span> <span class="symbol">:inc</span>
  <span class="symbol">:onyx/fn</span> <span class="symbol">:onyx.peer.min-peers-test/my-inc</span>
  <span class="symbol">:onyx/type</span> <span class="symbol">:function</span>
  <span class="symbol">:onyx/batch-size</span> batch-size}

 {<span class="symbol">:onyx/name</span> <span class="symbol">:out</span>
  <span class="symbol">:onyx/plugin</span> <span class="symbol">:onyx.plugin.core-async/output</span>
  <span class="symbol">:onyx/type</span> <span class="symbol">:output</span>
  <span class="symbol">:onyx/medium</span> <span class="symbol">:core.async</span>
  <span class="symbol">:onyx/batch-size</span> batch-size
  <span class="symbol">:onyx/max-peers</span> <span class="integer">1</span>
  <span class="symbol">:onyx/doc</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Writes segments to a core.async channel</span><span class="delimiter">&quot;</span></span>}]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_flow_conditions"><a class="anchor" href="#_flow_conditions"></a>Flow Conditions</h4>
<div class="paragraph">
<p>In contrast to a workflow, flow conditions specify on a
segment-by-segment basis which direction data should flow determined by
predicate functions. This is helpful for conditionally processing a
segment based off of its content.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[{<span class="symbol">:flow/from</span> <span class="symbol">:input-stream</span>
  <span class="symbol">:flow/to</span> [<span class="symbol">:process-adults</span>]
  <span class="symbol">:flow/predicate</span> <span class="symbol">:my.ns/adult?</span>
  <span class="symbol">:flow/doc</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Emits segment if this segment is an adult.</span><span class="delimiter">&quot;</span></span>}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_function"><a class="anchor" href="#_function"></a>Function</h4>
<div class="paragraph">
<p>A function is a construct that receives segments and emits segments for
further processing. It literally is a Clojure function.</p>
</div>
</div>
<div class="sect3">
<h4 id="_lifecycle"><a class="anchor" href="#_lifecycle"></a>Lifecycle</h4>
<div class="paragraph">
<p>A lifecycle is a construct that describes the lifetime of a task. There
is an entire chapter devoted to lifecycles, but to be brief, a lifecycle
allows you to hook in and execute arbitrary code at critical points
during a task. A lifecycle carries a context map that you can merge
results back into for use later.</p>
</div>
</div>
<div class="sect3">
<h4 id="_windows"><a class="anchor" href="#_windows"></a>Windows</h4>
<div class="paragraph">
<p>Windows are a construct that partitions a possible unbounded sequence of
data into finite pieces, allowing aggregations to be specified. This
lets you treat an infinite sequence of data as if it were finite over a
given period of time.</p>
</div>
</div>
<div class="sect3">
<h4 id="_plugin"><a class="anchor" href="#_plugin"></a>Plugin</h4>
<div class="paragraph">
<p>A plugin is a means for hooking into data sources to extract data as
input and produce data as output. Onyx comes with a few plugins, but you
can craft your own, too.</p>
</div>
</div>
<div class="sect3">
<h4 id="_sentinel"><a class="anchor" href="#_sentinel"></a>Sentinel</h4>
<div class="paragraph">
<p>A sentinel is a value that can be pushed into Onyx to signal the end of
a stream of data. This effectively lets Onyx switch between streaming
and batching mode. The sentinel in Onyx is represented by the Clojure
keyword <code>:done</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_peer"><a class="anchor" href="#_peer"></a>Peer</h4>
<div class="paragraph">
<p>A Peer is a node in the cluster responsible for processing data. A
single "peer" refers to a physical machine, though we often use the
terms peer and virtual peer interchangeably when the difference doesn&#8217;t
matter.</p>
</div>
</div>
<div class="sect3">
<h4 id="_virtual_peer"><a class="anchor" href="#_virtual_peer"></a>Virtual Peer</h4>
<div class="paragraph">
<p>A Virtual Peer refers to a single peer process running on a single
physical machine. A single Virtual Peer executes at most one task at a
time.</p>
</div>
</div>
<div class="sect3">
<h4 id="_job"><a class="anchor" href="#_job"></a>Job</h4>
<div class="paragraph">
<p>A job is the collection of a workflow, catalog, flow conditions,
lifecycles, and execution parameters. A job is most coarse unit of work,
and every task is associated with exactly one job - hence a peer can
only be working at most one job at any given time.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="low-level-design"><a class="anchor" href="#low-level-design"></a>Architecture &amp; Low Level Design</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter outlines how Onyx works on the inside to meet the required
properties of a distributed data processing system. This is not a formal
proof nor an iron-clad specification for other implementations of Onyx.
I will do my best to be transparent about how everything is working
under the hood - good and bad. If something doesn&#8217;t make sense, <em>keep
moving</em>. There are inevitable forward references.</p>
</div>
<div class="sect2">
<h3 id="_high_level_components"><a class="anchor" href="#_high_level_components"></a>High Level Components</h3>
<div class="sect3">
<h4 id="_peer_2"><a class="anchor" href="#_peer_2"></a>Peer</h4>
<div class="paragraph">
<p>A Peer is a node in the cluster responsible for processing data. A peer
generally refers to a physical machine as its typical to only run one
peer per machine.</p>
</div>
</div>
<div class="sect3">
<h4 id="_virtual_peer_2"><a class="anchor" href="#_virtual_peer_2"></a>Virtual Peer</h4>
<div class="paragraph">
<p>A Virtual Peer refers to a single concurent worker running on a single
physical machine. Each virtual peer spawns a small number threads since
it uses asynchronous messaging. All virtual peers are equal, whether
they are on the same physical machine or not. Virtual peers communicate
segments <em>directly</em> to one another, and coordinate <em>strictly</em> via the
log in ZooKeeper.</p>
</div>
</div>
<div class="sect3">
<h4 id="_zookeeper"><a class="anchor" href="#_zookeeper"></a>ZooKeeper</h4>
<div class="paragraph">
<p>Apache ZooKeeper is used as both storage and communication layer.
ZooKeeper takes care of things like CAS, consensus, and atomic counting.
ZooKeeper watches are at the heart of how Onyx virtual peers detect
machine failure.</p>
</div>
</div>
<div class="sect3">
<h4 id="_aeron"><a class="anchor" href="#_aeron"></a>Aeron</h4>
<div class="paragraph">
<p>Aeron is the primary messaging transport layer. The transport layer is
pluggable, though we don&#8217;t support any other transports at this time
since Aeron can "short-circuit" networking and act as fast as
core.async.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_log"><a class="anchor" href="#_the_log"></a>The Log</h4>
<div class="paragraph">
<p>This design centers around a totally ordered sequence of commands using
a log structure. The log acts as an immutable history and arbiter. It&#8217;s
maintained through ZooKeeper using a directory of persistent, sequential
znodes. Virtual peers act as processes that consume from the log. At the
time a peer starts up, it initializes its <em>local replica</em> to the "empty
state". Log entries represent deterministic, idempotent functions to be
applied to the local replica. The peer plays the log from the beginning,
applying each log entry to its local replica. The local replica is
transformed from one value to another. As a reaction to each replica
transformation, the peer may send more commands to the tail of the log.
Peers may play the log at any rate. After each peer has played <code>k</code> log
entries, all peers at time <code>k</code> will have <em>exactly</em> the same local
replica. Peers store everything in memory - so if a peer fails, it
simply reboots from scratch with a new identifier and plays the log
forward from the beginning. Since it has a new identifier, it has no
association to the commands it previously issued; this prevents live
lock issues.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_inbox_and_outbox"><a class="anchor" href="#_the_inbox_and_outbox"></a>The Inbox and Outbox</h4>
<div class="paragraph">
<p>Every peer maintains its own inbox and output. Messages received appear
in order on the inbox, and messages to-be-sent are placed in order on
the outbox.</p>
</div>
<div class="paragraph">
<p>Messages arrive in the inbox as commands are proposed into the ZooKeeper
log. Technically, the inbox need only be size 1 since all log entries
are processed strictly in order. As an optimization, the peer can choose
to read a few extra commands behind the one it&#8217;s currently processing.
In practice, the inbox will probably be configured with a size greater
than one.</p>
</div>
<div class="paragraph">
<p>The outbox is used to send commands to the log. Certain commands
processed by the peer will generate <em>other</em> commands. For example, if a
peer is idle and it receives a command notifying it about a new job, the
peer will <em>react</em> by sending a command to the log requesting that it be
allocated for work. Each peer can choose to <em>pause</em> or <em>resume</em> the
sending of its outbox messages. This is useful when the peer is just
acquiring membership to the cluster. It will have to play log commands
to join the cluster fully, but it cannot volunteer to be allocated for
work since it&#8217;s not officially yet a member of the cluster.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_applying_log_entries"><a class="anchor" href="#_applying_log_entries"></a>Applying Log Entries</h3>
<div class="paragraph">
<p>This section describes how log entries are applied to the peer&#8217;s local
replica. A log entry is a persistent, sequential znode. Its content is a
map with keys <code>:fn</code> and <code>:args</code>. <code>:fn</code> is mapped to a keyword that finds
this log entry&#8217;s implementation. <code>:args</code> is mapped to another map with
any data needed to apply the log entry to the replica.</p>
</div>
<div class="paragraph">
<p>Peers begin with the empty state value, and local state. Local state
maintains a mapping of things like the inbox and outbox - things that
are specific to <em>this</em> peer, and presumably can&#8217;t be serialized as EDN.</p>
</div>
<div class="paragraph">
<p>Each peer starts a thread that listens for additions to the log. When
the log gets a new entry, the peer calls
<code>onyx.extensions/apply-log-entry</code>. This is a function that takes a log
entry and the replica, and returns a new replica with the log entry
applied to it. This is a value-to-value transformation.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/diagram-1.png" alt="diagram 1" width="75%" height="75%">
</div>
</div>
<div class="paragraph">
<p><em>A single peer begins with the empty replica (<code>{}</code>) and progressively
applies log entries to the replica, advancing its state from one
immutable value to the next.</em></p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/diagram-2.png" alt="diagram 2" width="65%" height="65%">
</div>
</div>
<div class="paragraph">
<p><em>A peer reads the first log entry and applies the function to its local
replica, moving the replica into a state "as of" entry 0</em></p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/diagram-4.png" alt="diagram 4" width="65%" height="65%">
</div>
</div>
<div class="paragraph">
<p><em>Because application of functions from the log against the replica are
deterministic and free of side effects, peers do not need to coordinate
about the speed that each plays the log. Peers read the log on
completely independent timelines</em></p>
</div>
<div class="paragraph">
<p>Peers effect change in the world by reacting to log entries. When a log
entry is applied, the peer calls <code>onyx.extensions/replica-diff</code>, passing
it the old and new replicas. The peer produces a value summarizing what
changed. This diff is used in subsequent sections to decide how to react
and what side-effects to carry out.</p>
</div>
<div class="paragraph">
<p>Next, the peer calls <code>onyx.extensions/reactions</code> on the old/new
replicas, the diff, and its local state. The peer can decide to submit
new entries back to the log as a reaction to the log entry it just saw.
It might react to "submit-job" with "volunteer-for-task", for instance.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/diagram-5.png" alt="diagram 5" width="85%" height="85%">
</div>
</div>
<div class="paragraph">
<p><em>After a peer reads a log entry and applies it to the log replica, it
will (deterministically!) react by appending zero or more log entries to
the tail of the log.</em></p>
</div>
<div class="paragraph">
<p>Finally, the peer can carry out side-effects by invoking
<code>onyx.extensions/fire-side-effects!</code>. This function will do things like
talking to ZooKeeper or writing to core.async channels. Isolating side
effects means that a subset of the test suite can operate on pure
functions alone. Each peer is tagged with a unique ID, and it looks for
this ID in changes to its replica. The ID acts very much like the object
orientated "this", in that it uses the ID to differentiate itself to
conditionally perform side effects across an otherwise uniformly
behaving distributed system.</p>
</div>
</div>
<div class="sect2">
<h3 id="_joining_the_cluster"><a class="anchor" href="#_joining_the_cluster"></a>Joining the Cluster</h3>
<div class="paragraph">
<p>Aside from the log structure and any strictly data/storage centric
znodes, ZooKeeper maintains another directory for pulses. Each peer
registers exactly one ephemeral node in the pulses directory. The name
of this znode is a UUID.</p>
</div>
<div class="sect3">
<h4 id="_3_phase_cluster_join_strategy"><a class="anchor" href="#_3_phase_cluster_join_strategy"></a>3-Phase Cluster Join Strategy</h4>
<div class="paragraph">
<p>When a peer wishes to join the cluster, it must engage in a 3 phase
protocol. Three phases are required because the peer that is joining
needs to coordinate with another peer to change its ZooKeeper watch. I
call this process "stitching" a peer into the cluster.</p>
</div>
<div class="paragraph">
<p>The technique needs peers to play by the following rules: - Every peer
must be watched by another peer in ZooKeeper, unless there is exactly
one peer in the cluster - in which case there are no watches. - When a
peer joins the cluster, all peers must form a "ring" in terms of
who-watches-who. This makes failure repair very easy because peers can
transitively close any gaps in the ring after machine failure. - As a
peer joining the cluster begins playing the log, it must buffer all
reactive messages unless otherwise specified. The buffered messages are
flushed after the peer has fully joined the cluster. This is because a
peer could volunteer to perform work, but later abort its attempt to
join the cluster, and therefore not be able to carry out any work. - A
peer picks another peer to watch by determining a candidate list of
peers it can stitch into. This candidate list is sorted by peer ID. The
target peer is chosen by taking the message id modulo the number of
peers in the sorted candidate list. The peer chosen can&#8217;t be random
because all peers will play the message to select a peer to stitch with,
and they must all determine the same peer. Hence, the message modulo
piece is a sort of "random seed" trick.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/diagram-7.png" alt="diagram 7" width="85%" height="85%">
</div>
</div>
<div class="paragraph">
<p><em>At monotonic clock value t = 42, the replica has the above <code>:pairs</code>
key, indicates who watches whom. As nodes are added, they maintain a
ring formation so that every peer is watched by another.</em></p>
</div>
<div class="paragraph">
<p>The algorithm works as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>let S = the peer to stitch into the cluster</p>
</li>
<li>
<p>S sends a <code>prepare-join-cluster</code> command to the log, indicating its
peer ID</p>
</li>
<li>
<p>S plays the log forward</p>
</li>
<li>
<p>Eventually, all peers encounter <code>prepare-join-cluster</code> message that
was sent by it</p>
</li>
<li>
<p>if the cluster size is <code>0</code>:</p>
</li>
<li>
<p>S instantly becomes part of the cluster</p>
</li>
<li>
<p>S flushes its outbox of commands</p>
</li>
<li>
<p>if the cluster size (<code>n</code>) is <code>&gt;= 1</code>:</p>
</li>
<li>
<p>let Q = this peer playing the log entry</p>
</li>
<li>
<p>let A = the set of all peers in the fully joined in the cluster</p>
</li>
<li>
<p>let X = the single peer paired with no one (case only when <code>n = 1</code>)</p>
</li>
<li>
<p>let P = set of all peers prepared to join the cluster</p>
</li>
<li>
<p>let D = set of all peers in A that are depended on by a peer in P</p>
</li>
<li>
<p>let V = sorted vector of <code>(set-difference (set-union A X) D)</code> by peer
ID</p>
</li>
<li>
<p>if V is empty:</p>
<div class="ulist">
<ul>
<li>
<p>S sends an <code>abort-join-cluster</code> command to the log</p>
</li>
<li>
<p>when S encounters <code>abort-join-cluster</code>, it backs off and tries to
join again later</p>
</li>
</ul>
</div>
</li>
<li>
<p>let T = nth in V of <code>message-id mod (count V)</code></p>
</li>
<li>
<p>let W = the peer that T watches</p>
</li>
<li>
<p>T adds a watch to S</p>
</li>
<li>
<p>T sends a <code>notify-join-cluster</code> command to the log, notifying S that
it is watched, adding S to P</p>
</li>
<li>
<p>when S encounters <code>notify-join-cluster</code>:</p>
<div class="ulist">
<ul>
<li>
<p>it adds a watch to W</p>
</li>
<li>
<p>it sends a <code>accept-join-cluster</code> command, removing S from P, adding S
to A</p>
</li>
</ul>
</div>
</li>
<li>
<p>when <code>accept-join-cluster</code> has been encountered, this peer is part of
the cluster</p>
</li>
<li>
<p>S flushes its outbox of commands</p>
</li>
<li>
<p>T drops its watch from W - it is now redundant, as S is watching W</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="img/diagram-13.png" alt="diagram 13" width="85%" height="85%">
</div>
</div>
<div class="paragraph">
<p><em>Peers 1 - 4 form a ring. Peer 5 wants to join. Continued below&#8230;&#8203;</em></p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/diagram-14.png" alt="diagram 14" width="85%" height="85%">
</div>
</div>
<div class="paragraph">
<p><em>Peer 5 initiates the first phase of the join protocol. Peer 1 prepares
to accept Peer 5 into the ring by adding a watch to it. Continued
below&#8230;&#8203;</em></p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/diagram-15.png" alt="diagram 15" width="85%" height="85%">
</div>
</div>
<div class="paragraph">
<p><em>Peer 5 initiates the second phase of the join protocol. Peer 5 notifies
Peer 4 as a peer to watch. At this point, a stable "mini ring" has been
stitched along the outside of the cluster. We note that the link between
Peer 1 and 4 is extraneous. Continued below&#8230;&#8203;</em></p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/diagram-16.png" alt="diagram 16" width="85%" height="85%">
</div>
</div>
<div class="paragraph">
<p><em>Peer 5 has been fully stitched into the cluster, and the ring is
intact</em></p>
</div>
</div>
<div class="sect3">
<h4 id="_examples"><a class="anchor" href="#_examples"></a>Examples</h4>
<div class="ulist">
<ul>
<li>
<p><a href="join-examples/example-1.md">Example 1: 3 node cluster, 1 peer
successfully joins</a></p>
</li>
<li>
<p><a href="join-examples/example-2.md">Example 2: 3 node cluster, 2 peers
successfully join</a></p>
</li>
<li>
<p><a href="join-examples/example-3.md">Example 3: 2 node cluster, 1 peer
successfully joins, 1 aborts</a></p>
</li>
<li>
<p><a href="join-examples/example-4.md">Example 4: 1 node cluster, 1 peer
successfully joins</a></p>
</li>
<li>
<p><a href="join-examples/example-5.md">Example 5: 0 node cluster, 1 peer
successfully joins</a></p>
</li>
<li>
<p><a href="join-examples/example-6.md">Example 6: 3 node cluster, 1 peer
fails to join due to 1 peer dying during 3-phase join</a></p>
</li>
<li>
<p><a href="join-examples/example-7.md">Example 7: 3 node cluster, 1 peer dies
while joining</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_dead_peer_removal"><a class="anchor" href="#_dead_peer_removal"></a>Dead peer removal</h3>
<div class="paragraph">
<p>Peers will fail, or be shut down purposefully. Onyx needs to: - detect
the downed peer - inform all peers that this peer is no longer executing
its task - inform all peers that this peer is no longer part of the
cluster</p>
</div>
<div class="sect3">
<h4 id="_peer_failure_detection_strategy"><a class="anchor" href="#_peer_failure_detection_strategy"></a>Peer Failure Detection Strategy</h4>
<div class="paragraph">
<p>In a cluster of &gt; 1 peer, when a peer dies another peer will have a
watch registered on its znode to detect the ephemeral disconnect. When a
peer fails (peer F), the peer watching the failed peer (peer W) needs to
inform the cluster about the failure, <em>and</em> go watch the node that the
failed node was watching (peer Z). The joining strategy that has been
outlined forces peers to form a ring. A ring structure has an advantage
because there is no coordination or contention as to who must now watch
peer Z for failure. Peer W is responsible for watching Z, because W
<em>was</em> watching F, and F <em>was</em> watching Z. Therefore, W transitively
closes the ring, and W watches Z. All replicas can deterministically
compute this answer without conferring with each other.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/diagram-8.png" alt="diagram 8" width="55%" height="55%">
</div>
</div>
<div class="paragraph">
<p><em>The nodes form a typical ring pattern. Peer 5 dies, and its connection
with ZooKeeper is severed. Peer 1 reacts by reporting Peer 5&#8217;s death to
the log. Continued below&#8230;&#8203;</em></p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/diagram-9.png" alt="diagram 9" width="85%" height="85%">
</div>
</div>
<div class="paragraph">
<p><em>At t = 45, all of the replicas realize that Peer 5 is dead, and that
Peer 1 is responsible for closing the gap by now watching Peer 4 to
maintain the ring.</em></p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/diagram-10.png" alt="diagram 10" width="85%" height="85%">
</div>
</div>
<div class="paragraph">
<p><em>One edge case of this design is the simultaneous death of two or more
consecutive peers in the ring. Suppose Peers 4 and 5 die at the exact
same time. Peer 1 will signal Peer 5&#8217;s death, but Peer 5 never got the
chance to signal Peer 4&#8217;s death. Continued below&#8230;&#8203;</em></p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/diagram-11.png" alt="diagram 11" width="85%" height="85%">
</div>
</div>
<div class="paragraph">
<p><em>Peer 1 signals Peer 5&#8217;s death, and closes to the ring by adding a watch
to Peer 4. Peer 4 is dead, but no one yet knows that. We circumvent this
problem by first determining whether a peer is dead or not before adding
a watch to it. If it&#8217;s dead, as is Peer 4 in this case, we report it and
further close the ring. Continued below&#8230;&#8203;</em></p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/diagram-12.png" alt="diagram 12" width="85%" height="85%">
</div>
</div>
<div class="paragraph">
<p><em>Peer 1 signals peer 4&#8217;s death, and further closes to the ring by adding
a watch to Peer 3. The ring is now fully intact.</em></p>
</div>
</div>
<div class="sect3">
<h4 id="_peer_failure_detection_thread"><a class="anchor" href="#_peer_failure_detection_thread"></a>Peer Failure Detection Thread</h4>
<div class="paragraph">
<p>There is a window of time (inbetween when a peer prepares to join the
cluster and when its monitoring peer notifies the cluster of its
presence) that the monitoring node may fail, effectively deadlocking the
new peer. This can occur because a peer will check if its monitoring
dead is dead during the prepare phase - essentially performing eviction
on a totally dead cluster - and may find a false positive that a node is
alive when it is actually dead. The root issue is that ephemeral znodes
stick around for a short period of time after the creating process goes
down. The new peer must watch its monitor until it delivers the second
phase message for joining - notification. When this occurs, we can stop
monitoring, because the monitoring node is clearly alive. If the znode
is deleted because the process exited, we can safely effect it and free
the peer from deadlocking.
<a href="https://github.com/onyx-platform/onyx/issues/416">Issue 416</a> found this
bug, and offers more context about the specific problem that we
encountered.</p>
</div>
</div>
<div class="sect3">
<h4 id="_examples_2"><a class="anchor" href="#_examples_2"></a>Examples</h4>
<div class="ulist">
<ul>
<li>
<p><a href="leave-examples/example-1.md">Example 1: 4 node cluster, 1 peer crashes</a></p>
</li>
<li>
<p><a href="leave-examples/example-2.md">Example 2: 4 node cluster, 2 peers
instantaneously crash</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_messaging"><a class="anchor" href="#_messaging"></a>Messaging</h3>
<div class="paragraph">
<p>The messaging layer of Onyx employees the same technique that Apache
Storm uses to achieve fault tolerance. Any errors are our own.</p>
</div>
<div class="sect3">
<h4 id="_the_algorithm"><a class="anchor" href="#_the_algorithm"></a>The Algorithm</h4>
<div class="paragraph">
<p>Onyx guarantees that each segment read from an input task will be
processed, and provide at-least-once delivery semantics. Every segment
that comes off an input task is given a UUID to track it through its
lifetime. It is also given a peer ID that it uses as an "acking daemon",
explained in more detail below. The segment also receives an initial
"ack val". The ack val is a random 64-bit integer. Each time a segment
is successfully processed at each task, this ack-val is XOR&#8217;ed with
itself. Further, any <em>new</em> segments that are generated as a result of
this segment being completed are given random ack vals, too. These ack
vals are also XOR&#8217;ed against the previous XOR value. When no new
segments are generated, the result of XOR&#8217;ing all the segment ack vals
returns 0. Finding 0 means that the segment has been successfully
processed throughout the entire workflow.</p>
</div>
</div>
<div class="sect3">
<h4 id="_acking_daemon"><a class="anchor" href="#_acking_daemon"></a>Acking Daemon</h4>
<div class="paragraph">
<p>An acking daemon is a process that runs alongside each peer and
maintains state. This state is a map of segment ID to another map. The
map in the value maintains the current "ack val" and the peer to send
completion messages to. When the ack val for a segment is set to zero, a
message is send to the appropriate peer to release the message from
durable storage. This concludes the processing of the segment, and it is
considered successful. Key/value pairs are periodically reaped if peers
that are operating on these segments are lost. If these values are
reaped, the message is automatically replayed from the root of the
workflow on the input task on a rolling basis.</p>
</div>
<div class="paragraph">
<p>We can depict all of this visually:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/messaging-summary.png" alt="messaging summary">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_phases_of_execution"><a class="anchor" href="#_phases_of_execution"></a>Phases of Execution</h4>
<div class="paragraph">
<p>A batch of segments runs through the following phases of execution in
sequential order:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Inject resources: Initiates any values for this particular batch</p>
</li>
<li>
<p>Read message batch: reads and decompresses messages from the transport
layer</p>
</li>
<li>
<p>Tag messages: If these are messages from an input task, uniquely tags
each segment to track it through its lifetime</p>
</li>
<li>
<p>Timeout pool: If these are messages from an input task, adds these
messages to a timeout pool to automatically expire on a preconfigured
schedule</p>
</li>
<li>
<p>Completion: Checks if this job has been completed, and shuts down the
job if so</p>
</li>
<li>
<p>Strip sentinel: Removes the sentinel if it&#8217;s in this batch, signal
that the job may be completed</p>
</li>
<li>
<p>Apply function: Apply fns to batches of segments</p>
</li>
<li>
<p>Build new segments: Creates and IDs new segments based on the received
segments</p>
</li>
<li>
<p>Write message batch: Writes messages to the next peer or output medium</p>
</li>
<li>
<p>Flow retry: Cause messages back at the input task to play again that
are force-retried via flow conditions.</p>
</li>
<li>
<p>Ack messages: Acknowledges the segments that have been processed to
the acking daemon</p>
</li>
<li>
<p>Close batch resources: Closes any resources opened for this specific
batch</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_garbage_collection"><a class="anchor" href="#_garbage_collection"></a>Garbage collection</h3>
<div class="paragraph">
<p>One of the primary obstacles that this design imposes is the requirement
of seemingly infinite storage. Log entries are only ever appended -
never mutated. If left running long enough, ZooKeeper will run out of
space. Similarly, if enough jobs are submitted and either completed or
killed, the in memory replica that each peer houses will grow too large.
Onyx requires a garbage collector to be periodically invoked.</p>
</div>
<div class="paragraph">
<p>When the garbage collector is invoked, two things will happen. The
caller of gc will place an entry onto the log. As each peer processed
this log entry, it carries out a deterministic, pure function to shrink
the replica. The second thing will occur when each peer invokes the side
effects for this log entry. The caller will have specified a unique ID
such that it is the only one that is allowed to trim the log. The caller
will take the current replica (log entry N to this log entry), and store
it in an "origin" znode. Anytime that a peer boots up, it first reads
out of the origin location. Finally, the caller deletes log entry N to
this log entry minus 1. This has the dual effect of making new peers
start up faster, as they have less of the log to play. They begin in a
"hot" state.</p>
</div>
<div class="paragraph">
<p>The garbage collector can be invoked by the public API function
<code>onyx.api/gc</code>. Upon returning, the log will be trimmed, and the in
memory replicas will be compressed.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/diagram-17.png" alt="diagram 17" width="85%" height="85%">
</div>
</div>
<div class="paragraph">
<p><em>A peer can start by reading out of the origin, and continue directly to
a particular log location.</em></p>
</div>
</div>
<div class="sect2">
<h3 id="_command_reference"><a class="anchor" href="#_command_reference"></a>Command Reference</h3>
<div class="paragraph">
<p><a href="https://github.com/onyx-platform/onyx/blob/master/src/onyx/log/commands/prepare_join_cluster.clj"><code>prepare-join-cluster</code></a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Submitter: peer (P) that wants to join the cluster</p>
</li>
<li>
<p>Purpose: determines which peer (Q) that will watch P. If P is the only
peer, it instantly fully joins the cluster</p>
</li>
<li>
<p>Arguments: P&#8217;s ID</p>
</li>
<li>
<p>Replica update: assoc <code>{Q P}</code> to <code>:prepare</code> key. If P is the only
peer, P is immediately added to the <code>:peers</code> key, and no further
reactions are taken</p>
</li>
<li>
<p>Side effects: Q adds a ZooKeeper watch to P&#8217;s pulse node</p>
</li>
<li>
<p>Reactions: Q sends <code>notify-join-cluster</code> to the log, with args P and R
(R being the peer Q watches currently)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/onyx-platform/onyx/blob/master/src/onyx/log/commands/notify_join_cluster.clj"><code>notify-join-cluster</code></a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Submitter: peer Q helping to stitch peer P into the cluster</p>
</li>
<li>
<p>Purpose: Adds a watch from P to R, where R is the node watched by Q</p>
</li>
<li>
<p>Arguments: P and R&#8217;s ids</p>
</li>
<li>
<p>Replica update: assoc <code>{Q P}</code> to <code>:accept</code> key, dissoc <code>{Q P}</code> from
<code>:prepare</code> key</p>
</li>
<li>
<p>Side effects: P adds a ZooKeeper watch to R&#8217;s pulse node</p>
</li>
<li>
<p>Reactions: P sends <code>accept-join-cluster</code> to the log, with args P, Q,
and R</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/onyx-platform/onyx/blob/master/src/onyx/log/commands/accept_join_cluster.clj"><code>accept-join-cluster</code></a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Submitter: peer P wants to join the cluster</p>
</li>
<li>
<p>Purpose: confirms that P can safely join, Q can drop its watch from R,
since P now watches R, and Q watches P</p>
</li>
<li>
<p>Arguments: P, Q, and R&#8217;s ids</p>
</li>
<li>
<p>Replica update: dissoc <code>{Q P}</code> from <code>:accept</code> key, merge <code>{Q P}</code> and
<code>{P R}</code> into <code>:pairs</code> key, conj P onto the <code>:peers</code> key</p>
</li>
<li>
<p>Side effects: Q drops its ZooKeeper watch from R</p>
</li>
<li>
<p>Reactions: peer P flushes its outbox of messages</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/onyx-platform/onyx/blob/master/src/onyx/log/commands/add_virtual_peer.clj"><code>add-virtual-peer</code></a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Submitter: virtual peer P wants to become active in the cluster</p>
</li>
<li>
<p>Purpose: P affirms that it&#8217;s peer group has been safely stitched into
the cluster</p>
</li>
<li>
<p>Arguments: P&#8217;s id</p>
</li>
<li>
<p>Replica update: conj P into <code>:peers</code>, remove from <code>:orphaned-peers</code></p>
</li>
<li>
<p>Side effects: All virtual peers configure their workload and possibly
start new tasks</p>
</li>
<li>
<p>Reactions: none</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/onyx-platform/onyx/blob/master/src/onyx/log/commands/abort_join_cluster.clj"><code>abort-join-cluster</code></a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Submitter: peer (Q) determines that peer (P) cannot join the cluster
(P may = Q)</p>
</li>
<li>
<p>Purpose: Aborts P&#8217;s attempt at joining the cluster, erases attempt
from replica</p>
</li>
<li>
<p>Arguments: P&#8217;s id</p>
</li>
<li>
<p>Replica update: Remove any <code>:prepared</code> or <code>:accepted</code> entries where P
is a key&#8217;s value</p>
</li>
<li>
<p>Side effects: P optionally backs off for a period</p>
</li>
<li>
<p>Reactions: P optionally sends <code>:prepare-join-cluster</code> to the log and
tries again</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/onyx-platform/onyx/blob/master/src/onyx/log/commands/group_leave_cluster.clj"><code>group-leave-cluster</code></a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Submitter: peer (Q) reporting that peer P is dead</p>
</li>
<li>
<p>Purpose: removes P from <code>:prepared</code>, <code>:accepted</code>, <code>:pairs</code>, and/or
<code>:peers</code>, transitions Q&#8217;s watch to R (the node P watches) and
transitively closes the ring</p>
</li>
<li>
<p>Arguments: peer ID of P</p>
</li>
<li>
<p>Replica update: assoc <code>{Q R}</code> into the <code>:pairs</code> key, dissoc <code>{P R}</code></p>
</li>
<li>
<p>Side effects: Q adds a ZooKeeper watch to R&#8217;s pulse node</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/onyx-platform/onyx/blob/master/src/onyx/log/commands/leave_cluster.clj"><code>leave-cluster</code></a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Submitter: virtual peer P is leaving the cluster</p>
</li>
<li>
<p>Purpose: removes P from its task and consideration of any future tasks</p>
</li>
<li>
<p>Arguments: peer ID of P</p>
</li>
<li>
<p>Replica update: removes P from <code>:peers</code></p>
</li>
<li>
<p>Side effects: All virtual peers reconfigure their workloads for
possibly new tasks</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/onyx-platform/onyx/blob/master/src/onyx/log/commands/seal_task.clj"><code>seal-task</code></a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Submitter: peer (P), who has seen the leader sentinel</p>
</li>
<li>
<p>Purpose: P wants to propagate the sentinel to all downstream tasks</p>
</li>
<li>
<p>Arguments: P&#8217;s ID (<code>:id</code>), the job ID (<code>:job</code>), and the task ID
(<code>:task</code>)</p>
</li>
<li>
<p>Replica update: If this peer is allowed to seal, updates
<code>:sealing-task</code> with the task ID associated this peers ID.</p>
</li>
<li>
<p>Side effects: Puts the sentinel value onto the queue</p>
</li>
<li>
<p>Reactions: None</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/onyx-platform/onyx/blob/master/src/onyx/log/commands/submit_job.clj"><code>submit-job</code></a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Submitter: Client, via public facing API</p>
</li>
<li>
<p>Purpose: Send a catalog and workflow to be scheduled for execution by
the cluster</p>
</li>
<li>
<p>Arguments: The job ID (<code>:id</code>), the task scheduler for this job
(<code>:task-scheduler</code>), a topologically sorted sequence of tasks
(<code>:tasks</code>), the catalog (<code>:catalog</code>), and the saturation level for this
job (<code>:saturation</code>). Saturation denotes the number of peers this job can
use, at most. This is typically Infinity, unless all catalog entries set
<code>:onyx/max-peers</code> to an integer value. Saturation is then the sum of
those numbers, since it creates an upper bound on the total number of
peers that can be allocated to this task.</p>
</li>
<li>
<p>Replica update:</p>
</li>
<li>
<p>Side effects: None</p>
</li>
<li>
<p>Reactions: If the job scheduler dictates that this peer should be
reallocated to this job or another job, sends <code>:volunteer-for-task</code> to
the log</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/onyx-platform/onyx/blob/master/src/onyx/log/commands/kill_job.clj"><code>kill-job</code></a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Submitter: Client, via public facing API</p>
</li>
<li>
<p>Purpose: Stop all peers currently working on this job, and never allow
this job&#8217;s tasks to be scheduled for execution again</p>
</li>
<li>
<p>Arguments: The job ID (<code>:job</code>)</p>
</li>
<li>
<p>Replica update: Adds this job id to <code>:killed-jobs</code> vector, removes any
peers in <code>:allocations</code> for this job&#8217;s tasks. Switches the <code>:peer-state</code>
for all peer&#8217;s executing a task for this job to <code>:idle</code>.</p>
</li>
<li>
<p>Side effects: If this peer is executing a task for this job, stops the
current task lifecycle</p>
</li>
<li>
<p>Reactions: If this peer is executing a task for this job, reacts with
<code>:volunteer-for-task</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/onyx-platform/onyx/blob/master/src/onyx/log/commands/gc.clj"><code>gc</code></a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Submitter: Client, via public facing API</p>
</li>
<li>
<p>Purpose: Compress all peer local replicas and trim old log entries in
ZooKeeper.</p>
</li>
<li>
<p>Arguments: The caller ID (<code>:id</code>)</p>
</li>
<li>
<p>Replica update: Clears out all data in all keys about completed and
killed jobs - as if they never existed.</p>
</li>
<li>
<p>Side effects: Deletes all log entries before this command&#8217;s entry,
creates a compressed replica at a special origin log location, and
updates to the pointer to the origin</p>
</li>
<li>
<p>Reactions: None</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/onyx-platform/onyx/blob/master/src/onyx/log/commands/signal_ready.clj"><code>signal-ready</code></a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Submitter: peer (P), who has successfully started its incoming buffer</p>
</li>
<li>
<p>Purpose: Indicates that this peer is ready to receive segments as
input</p>
</li>
<li>
<p>Replica update: Updates <code>:peer-state</code> under the <code>:id</code> of this peer to
set its state to <code>:active</code>.</p>
</li>
<li>
<p>Side effects: If this task should immediately be sealed, seals this
task</p>
</li>
<li>
<p>Reactions: None.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/onyx-platform/onyx/blob/master/src/onyx/log/commands/set_replica.clj"><code>set-replica!</code></a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Submitter: This is a special entry that should never be appended to
the log</p>
</li>
<li>
<p>Purpose: Perform a hard reset of the replica, replacing its entire
value. This is useful if a log subscriber is reading behind a garbage
collection call and tries to read a non-existent entry. The new origin
can be found and its value applied locally via the subscriber.</p>
</li>
<li>
<p>Replica update: Replaces the entire value of the replica with a new
value</p>
</li>
<li>
<p>Side effects: None.</p>
</li>
<li>
<p>Reactions: None.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/onyx-platform/onyx/blob/master/src/onyx/log/commands/assign_bookkeeper_log_id.clj"><code>assign-bookkeeper-log-id</code></a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Submitter: Peer that performs log initialization.</p>
</li>
<li>
<p>Purpose: Sets an identifier to the ledger that will track the state
represented by this log.</p>
</li>
<li>
<p>Replica update: Updates <code>:state-logs</code> with the id.</p>
</li>
<li>
<p>Side effects: None.</p>
</li>
<li>
<p>Reactions: None.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_apis"><a class="anchor" href="#_apis"></a>APIs</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Onyx ships with two distinct APIs to accommodate different needs. A
description of each follows.</p>
</div>
<div class="sect2">
<h3 id="core-api"><a class="anchor" href="#core-api"></a>Core API</h3>
<div class="paragraph">
<p>The
<a href="https://github.com/onyx-platform/onyx/blob/0.9.x/src/onyx/api.clj">Core
API</a> is used to start/stop resources, jobs, and monitor job progress.
It&#8217;s accessible through the <code>onyx.api</code> namespace.</p>
</div>
<div class="sect3">
<h4 id="start-env"><a class="anchor" href="#start-env"></a>start-env</h4>
<div class="paragraph">
<p>Starts a development environment with in-memory ZooKeeper. Helpful for
developing locally without needing to start any other services.</p>
</div>
</div>
<div class="sect3">
<h4 id="start-peer-group"><a class="anchor" href="#start-peer-group"></a>start-peer-group</h4>
<div class="paragraph">
<p>Starts a resource pool to be shared across a group of peers. You should
only start one peer group per physical machine.</p>
</div>
</div>
<div class="sect3">
<h4 id="start-peers"><a class="anchor" href="#start-peers"></a>start-peers</h4>
<div class="paragraph">
<p>Starts N virtual peers to execute tasks. In a production environment,
you should start by booting up N virtual peers for N cores on the
physical machine. Tune performance from there.</p>
</div>
</div>
<div class="sect3">
<h4 id="submit-job"><a class="anchor" href="#submit-job"></a>submit-job</h4>
<div class="paragraph">
<p>Submits a job to Onyx to be scheduled for execution. Takes a map with
keys <code>:catalog</code>, <code>:workflow</code>, <code>:flow-conditions</code>, <code>:windows</code>,
<code>:triggers</code>, <code>:metadata</code>, and <code>:task-scheduler</code>. Returns a map of
<code>:job-id</code> and <code>:task-ids</code>, which map to a UUID and vector of maps
respectively. <code>:metadata</code> is a map of values that must serialize to EDN.
<code>:metadata</code> will be logged with all task output, and is useful for
identifying a particular task based on something other than its name or
ID.</p>
</div>
<div class="paragraph">
<p>Additionally, <code>:metadata</code> may optionally contain a <code>:job-id</code> key. When
specified, this key will be used for the job ID instead of a randomly
chosen UUID. Repeated submissions of a job with the same :job-id will be
treated as an idempotent action. If a job with the same ID has been
submitted more than once, the original task IDs associated with the
catalog will be returned, and the job will not run again, even if it has
been killed or completed. It is undefined behavior to submit two jobs
with the same :job-id metadata whose :workflow, :catalog,
:flow-conditions, etc are not equal.</p>
</div>
</div>
<div class="sect3">
<h4 id="await-job-completion"><a class="anchor" href="#await-job-completion"></a>await-job-completion</h4>
<div class="paragraph">
<p>Given a job ID, blocks the calling thread until all the tasks for this
job have been completed.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Example project:
<a href="https://github.com/onyx-platform/onyx-examples/tree/0.9.x/block-on-job-completion">block-on-job-completion</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="gc"><a class="anchor" href="#gc"></a>gc</h4>
<div class="paragraph">
<p>Invokes the garbage collector. Compresses the replica in Zookeeper,
freeing up storage and deleting log history. Frees up memory on the
local, in memory replica on all peers.</p>
</div>
</div>
<div class="sect3">
<h4 id="kill-job"><a class="anchor" href="#kill-job"></a>kill-job</h4>
<div class="paragraph">
<p>Stops this job from executing, never allowing it to be run again.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Example project:
<a href="https://github.com/onyx-platform/onyx-examples/tree/0.9.x/kill-job">kill-job</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="subscribe-to-log"><a class="anchor" href="#subscribe-to-log"></a>subscribe-to-log</h4>
<div class="paragraph">
<p>Sends all events in the log to a core.async channel. Events are received
in the order that they appeared in the log. Starts from the beginning of
the log, blocking until more entries are available.</p>
</div>
</div>
<div class="sect3">
<h4 id="shutdown-peer"><a class="anchor" href="#shutdown-peer"></a>shutdown-peer</h4>
<div class="paragraph">
<p>Shuts down a single peer, stopping any task that it is presently
executing.</p>
</div>
</div>
<div class="sect3">
<h4 id="shutdown-peer-group"><a class="anchor" href="#shutdown-peer-group"></a>shutdown-peer-group</h4>
<div class="paragraph">
<p>Shuts down the peer group, releasing any messaging resources it was
holding open.</p>
</div>
</div>
<div class="sect3">
<h4 id="shutdown-env"><a class="anchor" href="#shutdown-env"></a>shutdown-env</h4>
<div class="paragraph">
<p>Shuts down the development environment and stops in memory ZooKeeper.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="peer-pipeline-api"><a class="anchor" href="#peer-pipeline-api"></a>Peer Pipeline API</h3>
<div class="paragraph">
<p>The
<a href="https://github.com/onyx-platform/onyx/blob/0.9.x/src/onyx/peer/pipeline_extensions.clj">Peer
Pipeline API</a> allows you to interact with data storage mediums to read
and write data for plugins.</p>
</div>
<div class="sect3">
<h4 id="read-batch"><a class="anchor" href="#read-batch"></a>read-batch</h4>
<div class="paragraph">
<p>Reads multiple segments off the previous element in the workflow.</p>
</div>
</div>
<div class="sect3">
<h4 id="write-batch"><a class="anchor" href="#write-batch"></a>write-batch</h4>
<div class="paragraph">
<p>Writes the batch with the function applied to the output stream.</p>
</div>
</div>
<div class="sect3">
<h4 id="seal-resource"><a class="anchor" href="#seal-resource"></a>seal-resource</h4>
<div class="paragraph">
<p>Called by one peer exactly once (subsequent calls occur if the sealing
peer fails) when the task is completing. Close out target output
resources.</p>
</div>
</div>
<div class="sect3">
<h4 id="ack-segment"><a class="anchor" href="#ack-segment"></a>ack-segment</h4>
<div class="paragraph">
<p>Acknowledges a segment natively on the input medium, causing the segment
to be released from durable storage.</p>
</div>
</div>
<div class="sect3">
<h4 id="retry-segment"><a class="anchor" href="#retry-segment"></a>retry-segment</h4>
<div class="paragraph">
<p>Processes a segment again from the root of the workflow.</p>
</div>
</div>
<div class="sect3">
<h4 id="pending"><a class="anchor" href="#pending"></a>pending?</h4>
<div class="paragraph">
<p>Given a segment ID, returns true if this segment is pending completion.</p>
</div>
</div>
<div class="sect3">
<h4 id="drained"><a class="anchor" href="#drained"></a>drained?</h4>
<div class="paragraph">
<p>Returns true if all messages on the input medium have successfully been
processed. Never returns true for an infinite message stream.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="functions"><a class="anchor" href="#functions"></a>Functions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section outlines how Onyx programs execute behavior. Onyx uses
plain Clojure functions to carry out distributed activity. You have the
option of performing grouping and aggregation on each function.</p>
</div>
<div class="sect2">
<h3 id="_functional_transformation"><a class="anchor" href="#_functional_transformation"></a>Functional Transformation</h3>
<div class="paragraph">
<p>A Function is a construct that takes a segment as a parameter and
outputs a segment or a seq of segments. Functions are meant to literally
transform a single unit of data in a functional manner. The following is
an example of a function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">my-inc</span> [{<span class="symbol">:keys</span> [n] <span class="symbol">:as</span> segment}]
  (<span class="keyword">assoc</span> segment <span class="symbol">:n</span> (<span class="keyword">inc</span> n)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that you may <em>only</em> pass segments between functions - no other
shape of data is allowed.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Example project:
<a href="https://github.com/onyx-platform/onyx-examples/tree/0.9.x/filtering">filtering</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_function_parameterization"><a class="anchor" href="#_function_parameterization"></a>Function Parameterization</h3>
<div class="paragraph">
<p>A function can be parameterized before a job is submitted to Onyx. The
segment is always the last argument to the function. There are multiple
ways to paramerize a function, and they can be used in combination.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Via the catalog <code>:onyx/params</code> entry</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">catalog</span>
{<span class="keyword">..</span><span class="keyword">.</span>
 <span class="symbol">:my/param-1</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">abc</span><span class="delimiter">&quot;</span></span>
 <span class="symbol">:my/param-2</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">def</span><span class="delimiter">&quot;</span></span>
 <span class="symbol">:onyx/params</span> [<span class="symbol">:my/param-1</span> <span class="symbol">:my/param-2</span>]
 <span class="keyword">..</span><span class="keyword">.</span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The function is then invoked with <code>(partial f "abc" "def")</code>. The order
is controlled by the vector of <code>:onyx/params</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Via <code>:onyx.core/params</code> in the <code>before-task-start</code> lifecycle hook</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">before-task-start-hook</span> [event lifecycle]
  {<span class="symbol">:onyx.core/params</span> [<span class="integer">42</span>]})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The function is then invoked with <code>(partial f 42)</code>.</p>
</div>
<div class="paragraph">
<p>Using this approach "hard sets" the parameters list. Other parameters
may already exist in <code>onyx.core/params</code>. If you want to retain those
parameter, concat them together and return the new value on
<code>onyx.core/params</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Via the <code>:onyx.peer/fn-params</code> peer configuration</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">peer-opts</span>
  {<span class="keyword">..</span><span class="keyword">.</span>
   <span class="symbol">:onyx.peer/fn-params</span> {<span class="symbol">:my-fn-name</span> [<span class="integer">64</span>]}})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The function is then invoked with <code>(partial f 64)</code>.</p>
</div>
<div class="paragraph">
<p>This approach is useful for parameterizing a task regardless of which
job it is in. If both <code>onyx.peer/fn-params</code> and <code>:onyx/params</code> are set
for the same task, they are concatenated together, with <code>fn-params</code>
coming first.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Example projects:
<a href="https://github.com/onyx-platform/onyx-examples/tree/0.9.x/parameterized">parameterized</a>,
<a href="https://github.com/onyx-platform/onyx-examples/tree/0.9.x/interface-injection">interface-injection</a>,
<a href="https://github.com/onyx-platform/onyx-examples/tree/0.9.x/catalog-parameters">catalog-parameters</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_grouping_aggregation"><a class="anchor" href="#_grouping_aggregation"></a>Grouping &amp; Aggregation</h3>
<div class="paragraph">
<p>Grouping ensures that "like" values are always routed to the same
virtual peer, presumably to compute an aggregate. Grouping is specified
inside of a catalog entry. There are two ways to group: by key of
segment, or by arbitrary function. Grouping by key is a convenience that
will reach into each segment and pin all segments with the same key
value in the segment together. Grouping functions receive a single
segment as input. The output of a grouping function is the value to
group on. Grouped functions must set keys <code>:onyx/min-peers</code> and
<code>:onyx/flux-policy</code>. See below for a description of these.</p>
</div>
</div>
<div class="sect2">
<h3 id="_group_by_key"><a class="anchor" href="#_group_by_key"></a>Group By Key</h3>
<div class="paragraph">
<p>To group by a key or a vector of keys in a segment, use
<code>:onyx/group-by-key</code> in the catalog entry:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:onyx/name</span> <span class="symbol">:sum-balance</span>
 <span class="symbol">:onyx/fn</span> <span class="symbol">:onyx.peer.kw-grouping-test/sum-balance</span>
 <span class="symbol">:onyx/type</span> <span class="symbol">:function</span>
 <span class="symbol">:onyx/group-by-key</span> <span class="symbol">:name</span>
 <span class="symbol">:onyx/min-peers</span> <span class="integer">3</span>
 <span class="symbol">:onyx/flux-policy</span> <span class="symbol">:continue</span>
 <span class="symbol">:onyx/batch-size</span> <span class="integer">1000</span>}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_group_by_function"><a class="anchor" href="#_group_by_function"></a>Group By Function</h3>
<div class="paragraph">
<p>To group by an arbitrary function, use <code>:onyx/group-by-fn</code> in the
catalog entry:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:onyx/name</span> <span class="symbol">:sum-balance</span>
 <span class="symbol">:onyx/fn</span> <span class="symbol">:onyx.peer.fn-grouping-test/sum-balance</span>
 <span class="symbol">:onyx/type</span> <span class="symbol">:function</span>
 <span class="symbol">:onyx/group-by-fn</span> <span class="symbol">:onyx.peer.fn-grouping-test/group-by-name</span>
 <span class="symbol">:onyx/min-peers</span> <span class="integer">3</span>
 <span class="symbol">:onyx/flux-policy</span> <span class="symbol">:continue</span>
 <span class="symbol">:onyx/batch-size</span> <span class="integer">1000</span>}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_flux_policies"><a class="anchor" href="#_flux_policies"></a>Flux Policies</h3>
<div class="paragraph">
<p>Functions that use the grouping feature are presumably stateful. For
this reason, unless <code>:continue</code> is used, once a job begins, no matter
how many peers are added to the cluster, no new peers will be allocated
to grouping tasks. When more peers are added after the job begins, the
hashing algorithm loses its consistency, and stateful operations won&#8217;t
work correctly.</p>
</div>
<div class="paragraph">
<p>Given the fact the Onyx will not add more peers to regular grouping
tasks after it begins, we introduce a new parameter - <code>:onyx/min-peers</code>.
This should be set to an integer that indicates the minimum number of
peers that will be allocated to this task before the job can begin. Onyx
<em>may</em> schedule more than the minimum number that you set. You can create
an upper bound by also using <code>:onyx/max-peers</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Example project:
<a href="https://github.com/onyx-platform/onyx-examples/tree/0.9.x/max-peers">max-peers</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>One concern that immediately needs to be handled is addressing what
happens if a peer on a grouping task leaves the cluster after the job
has begun? Clearly, removing a peer from a grouping task also breaks the
consistent hashing algorithm that supports statefulness. The policy that
is enforced is configurable, and must be chosen by the developer. We
offer three policies, outlined below.</p>
</div>
<div class="sect3">
<h4 id="_continue_policy"><a class="anchor" href="#_continue_policy"></a>Continue Policy</h4>
<div class="paragraph">
<p>When <code>:onyx/flux-policy</code> is set to <code>:continue</code> on a catalog entry, the
hashing algorithm may be inconsistent. Peers can leave or join a task at
any point in time. This is desirable for streaming jobs where the data
is theoretically infinite or have tasks that benefit from grouping but
are not stateful.</p>
</div>
</div>
<div class="sect3">
<h4 id="_kill_policy"><a class="anchor" href="#_kill_policy"></a>Kill Policy</h4>
<div class="paragraph">
<p>When <code>:onyx/flux-policy</code> is set to <code>:kill</code>, the job is killed and all
peers abort execution of the job. Some jobs cannot compute correct
answers if there is a shift in the hashing algorithm&#8217;s consistency. An
example of this is a word count batch job.</p>
</div>
</div>
<div class="sect3">
<h4 id="_recover_policy"><a class="anchor" href="#_recover_policy"></a>Recover Policy</h4>
<div class="paragraph">
<p>When <code>:onyx/flux-policy</code> is set to <code>:recover</code>, the job continues as
is if any peers abort execution of the task. If any other peers are
available, they will be added to this task to progressively meet the
<code>:onyx/min-peers</code> number of peers concurrently working on this task.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_batch_functions"><a class="anchor" href="#_batch_functions"></a>Batch Functions</h3>
<div class="paragraph">
<p>Sometimes you might be able to perform a function more efficiently over
a batch of segments rather than processing one segment at a time, such
as writing segments to a database in a non-output task. You can receive
the entire batch of segments as an argument to your task by
setting <code>:onyx/batch-fn?</code> to <code>true</code> in your catalog entry for your function.
Your function <em>must</em> return a sequence with the same number of elements
as its incoming batch has. The elements are then matched up positionally to
pair parent segments with their outgoing child segments. Elements in the output
may either be a single segment or a vector of segments, as normal.
The utility of this feature is you can use functions that are more efficient over
a large number of segments rather than one at a time.</p>
</div>
<div class="paragraph">
<p>An example catalog entry:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:onyx/name</span> <span class="symbol">:inc</span>
 <span class="symbol">:onyx/fn</span> <span class="symbol">:onyx.peer.batch-function-test/my-inc</span>
 <span class="symbol">:onyx/type</span> <span class="symbol">:function</span>
 <span class="symbol">:onyx/batch-fn?</span> <span class="predefined-constant">true</span>
 <span class="symbol">:onyx/batch-size</span> batch-size}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And an example catalog function to correspond to this entry:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">my-inc</span> [segments]
  (<span class="keyword">map</span> #(<span class="keyword">update-in</span> % [<span class="symbol">:n</span>] <span class="keyword">inc</span>) segments))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default value for this option is <code>false</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_leaf_functions"><a class="anchor" href="#_leaf_functions"></a>Leaf Functions</h3>
<div class="paragraph">
<p>Sometimes you&#8217;re going to want a node in your workflow with no outgoing
connections that doesn&#8217;t perform I/O against a database. You can do this
by setting <code>:onyx/type</code> to <code>:output</code>, <code>:onyx/medium</code> to <code>:function</code>, and
<code>:onyx/plugin</code> to <code>onyx.peer.function/function</code>. Then you can specify an
<code>:onyx/fn</code> pointing to a regular Clojure function. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:onyx/name</span> <span class="symbol">:leaf-task</span>
 <span class="symbol">:onyx/fn</span> <span class="symbol">::add-to-results</span>
 <span class="symbol">:onyx/plugin</span> <span class="symbol">:onyx.peer.function/function</span>
 <span class="symbol">:onyx/medium</span> <span class="symbol">:function</span>
 <span class="symbol">:onyx/type</span> <span class="symbol">:output</span>
 <span class="symbol">:onyx/batch-size</span> <span class="integer">20</span>}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="flow-conditions"><a class="anchor" href="#flow-conditions"></a>Flow Conditions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section covers flow conditions. Flow conditions are used for
isolating logic about whether or not segments should pass through
different tasks in a workflow, and support a rich degree of composition
with runtime parameterization.</p>
</div>
<div class="sect2">
<h3 id="_summary"><a class="anchor" href="#_summary"></a>Summary</h3>
<div class="paragraph">
<p>Workflows specify the structure of your computation as a directed,
acyclic graph. A workflow describes all <em>possible</em> routes that a segment
can take as it enters your workflow. On the other hand, we often have
the need to specify how an <em>individual</em> segment moves throughout your
workflow. Many times, a segment conditionally moves from one task to
another. This is a concept that Onyx takes apart and turns into its own
idea, independent of the rest of your computation. They&#8217;re called Flow
Conditions. It should be mentioned straight away that Flow Conditions
are entirely optional, and your program can ignore them entirely if
you&#8217;d like. Omitting them leads to the default behavior, which sends a
segment to all immediate downstream tasks.</p>
</div>
</div>
<div class="sect2">
<h3 id="_motivating_example"><a class="anchor" href="#_motivating_example"></a>Motivating Example</h3>
<div class="paragraph">
<p>The easiest way to learn how to use flow conditions is to see an
example. Suppose we have the following workflow snippet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[[<span class="symbol">:input-stream</span> <span class="symbol">:process-children</span>]
 [<span class="symbol">:input-stream</span> <span class="symbol">:process-adults</span>]
 [<span class="symbol">:input-stream</span> <span class="symbol">:process-female-athletes</span>]
 [<span class="symbol">:input-stream</span> <span class="symbol">:process-everyone</span>]
 <span class="keyword">..</span><span class="keyword">.</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>This workflow takes some input in (presumably a stream of people), and
directs segments to four possible tasks - <code>:process-children</code>,
<code>:process-adults</code>, <code>:process-female-athletes</code>, and <code>:process-everyone</code>.
Suppose we want to <em>conditionally</em> direct a segment to zero or more of
these tasks, depending on some predicates. We use flow conditions to
carry out this work. Flow conditions are their own data structure that
are bundled along with the workflow and catalog to <code>onyx.api/submit-job</code>
(with key <code>:flow-conditions</code>). Here&#8217;s an example of what a flow
conditions data structure would look like for our proposed workflow:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[{<span class="symbol">:flow/from</span> <span class="symbol">:input-stream</span>
  <span class="symbol">:flow/to</span> [<span class="symbol">:process-children</span>]
  <span class="symbol">:my/max-child-age</span> <span class="integer">17</span>
  <span class="symbol">:flow/predicate</span> [<span class="symbol">:my.ns/child?</span> <span class="symbol">:my/max-child-age</span>]
  <span class="symbol">:flow/doc</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Emits segment if this segment is a child.</span><span class="delimiter">&quot;</span></span>}

 {<span class="symbol">:flow/from</span> <span class="symbol">:input-stream</span>
  <span class="symbol">:flow/to</span> [<span class="symbol">:process-adults</span>]
  <span class="symbol">:flow/predicate</span> <span class="symbol">:my.ns/adult?</span>
  <span class="symbol">:flow/doc</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Emits segment if this segment is an adult.</span><span class="delimiter">&quot;</span></span>}

 {<span class="symbol">:flow/from</span> <span class="symbol">:input-stream</span>
  <span class="symbol">:flow/to</span> [<span class="symbol">:process-female-athletes</span>]
  <span class="symbol">:flow/predicate</span> [<span class="symbol">:and</span> <span class="symbol">:my.ns/female?</span> <span class="symbol">:my.ns/athlete?</span>]
  <span class="symbol">:flow/doc</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Emits segment if this segment is a female athlete.</span><span class="delimiter">&quot;</span></span>}

 {<span class="symbol">:flow/from</span> <span class="symbol">:input-stream</span>
  <span class="symbol">:flow/to</span> [<span class="symbol">:process-everyone</span>]
  <span class="symbol">:flow/predicate</span> <span class="symbol">:my.ns/constantly-true</span>
  <span class="symbol">:flow/doc</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Always emit this segment</span><span class="delimiter">&quot;</span></span>}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The basic idea is that every entry in the Flow Conditions data structure
denotes a relationship between a task and its downstream tasks.
<code>:flow/from</code> indicates the task that the segment is leaving, and
<code>:flow/to</code> indicates the tasks that the segment should be sent to if the
predicate evaluates to true. The predicate is denoted by
<code>:flow/predicate</code>, which is a keyword or sequence of keywords that are
resolved to a function. Later in this section, we&#8217;ll cover how exactly
the predicate function is constructed.</p>
</div>
<div class="paragraph">
<p>There is <em>one</em> flow conditions data structure per job - that is, there
is one vector of maps. The order that you specify the flow conditions in
matters. More on that later in this section.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Example project:
<a href="https://github.com/onyx-platform/onyx-examples/tree/0.9.x/flow-combine">flow-combine</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_predicate_function_signatures"><a class="anchor" href="#_predicate_function_signatures"></a>Predicate Function Signatures</h3>
<div class="paragraph">
<p>A predicate function is a Clojure function that takes at least four
parameters - a context map, the old segment, the new segment, and the
collection of all new segments produced from the old segment. Predicates
can take parameters at runtime. They will be appended to the end of the
function invocation. See Predicate Parameters for further discussion of
how to use runtime parameters.</p>
</div>
<div class="paragraph">
<p>Predicates for the above examples can be seen below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">child?</span> [event old-segment new-segment all-new max-age]
  (<span class="keyword">&lt;=</span> (<span class="symbol">:age</span> new-segment) max-age))

(<span class="keyword">defn</span> <span class="function">adult?</span> [event old-segment new-segment all-new]
  (<span class="keyword">&gt;=</span> (<span class="symbol">:age</span> new-segment) <span class="integer">18</span>))

(<span class="keyword">defn</span> <span class="function">female?</span> [event old-segment new-segment all-new]
  (<span class="keyword">=</span> (<span class="symbol">:gender</span> new-segment) <span class="string"><span class="delimiter">&quot;</span><span class="content">Female</span><span class="delimiter">&quot;</span></span>))

(<span class="keyword">defn</span> <span class="function">athlete?</span> [event old-segment new-segment all-new]
  (<span class="keyword">=</span> (<span class="symbol">:job</span> new-segment) <span class="string"><span class="delimiter">&quot;</span><span class="content">athlete</span><span class="delimiter">&quot;</span></span>))

(<span class="keyword">def</span> <span class="function">constantly-true</span> (<span class="keyword">constantly</span> <span class="predefined-constant">true</span>))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_predicate_parameters"><a class="anchor" href="#_predicate_parameters"></a>Predicate Parameters</h3>
<div class="paragraph">
<p>Predicate functions can take parameters at runtime. In this first flow
condition, we use the parameter <code>:my/max-child-age</code> and set its value to
<code>17</code>. We pass this value to the predicate by surrounding it with
brackets, as in: <code>[:my.ns/child? :my/max-child-age]</code>. The parameters are
appended to the end of the function call to the predicate. See Predicate
Function Signatures in this section to see the arguments that are passed
into the predicate regardless each invocation.</p>
</div>
</div>
<div class="sect2">
<h3 id="_key_exclusion"><a class="anchor" href="#_key_exclusion"></a>Key Exclusion</h3>
<div class="paragraph">
<p>Sometimes, the decision of whether to allow a segment to pass through to
the next task depends on some side effects that were a result of the
original segment transformation. Onyx allows you to handle this case by
adding extra keys to your segment that comes out of the transformation
function. These extra keys are visible in your predicate function, and
then stripped off before being sent to the next task. You can indicate
these "extra keys" by the setting <code>:onyx/exclude-keys</code> to a vector of
keys.</p>
</div>
<div class="paragraph">
<p>For example, if we had the following transformation function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">my-function</span> [x]
  (<span class="keyword">assoc</span> x <span class="symbol">:result</span> <span class="integer">42</span> <span class="symbol">:side-effects-result</span> <span class="symbol">:blah</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Our predicate for flow conditions might need to use the
<code>:side-effects-result</code> to make a decision. We don&#8217;t want to actually
send that information over out to the next task, though - so we
<code>:flow/exclude-keys</code> on <code>:side-effects-results</code> to make it disappear
after the predicate result has been realized.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:flow/from</span> <span class="symbol">:input-stream</span>
 <span class="symbol">:flow/to</span> [<span class="symbol">:process-adults</span>]
 <span class="symbol">:flow/predicate</span> <span class="symbol">:my.ns/adult?</span>
 <span class="symbol">:flow/exclude-keys</span> [<span class="symbol">:side-effects-result</span>]
 <span class="symbol">:flow/doc</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Emits segment if this segment is an adult.</span><span class="delimiter">&quot;</span></span>}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Example project:
<a href="https://github.com/onyx-platform/onyx-examples/tree/0.9.x/flow-exclude-keys">flow-exclude-keys</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_predicate_composition"><a class="anchor" href="#_predicate_composition"></a>Predicate Composition</h3>
<div class="paragraph">
<p>One extraordinarily powerful feature of Flow Conditions is
its composition characteristics. Predicates can be composed
with logical <code>and</code>, <code>or</code>, and <code>not</code>. We use composition to check
if the segment is both female and an athlete in
<code>[:and :my.ns/female? :my.ns/athlete?]</code>. Logical function calls
must be surrounded with brackets, and may be nested arbitrarily.
Functions inside of logical operator calls may be parameterized,
as in <code>[:and :my.ns/female? [:my.ns/child? :my/max-child-age]]</code>.
Parameters <em>may not</em> specify logical functions.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Example project:
<a href="https://github.com/onyx-platform/onyx-examples/tree/0.9.x/flow-predicate-composition">flow-predicate-composition</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_match_all_none"><a class="anchor" href="#_match_all_none"></a>Match All/None</h3>
<div class="paragraph">
<p>Sometimes, you want a flow condition that emits a value to all tasks if
the predicate is true. You can use short hand to emit to all downstream
tasks:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:flow/from</span> <span class="symbol">:input-stream</span>
 <span class="symbol">:flow/to</span> <span class="symbol">:all</span>
 <span class="symbol">:flow/short-circuit?</span> <span class="predefined-constant">true</span>
 <span class="symbol">:flow/predicate</span> <span class="symbol">:my.ns/adult?</span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, sometimes you want to emit to no downstream tasks:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:flow/from</span> <span class="symbol">:input-stream</span>
 <span class="symbol">:flow/to</span> <span class="symbol">:none</span>
 <span class="symbol">:flow/short-circuit?</span> <span class="predefined-constant">true</span>
 <span class="symbol">:flow/predicate</span> <span class="symbol">:my.ns/adult?</span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If a flow condition specifies <code>:all</code> as its <code>:flow/to</code>, it must come
before any other flow conditions. If a flow condition specifies <code>:none</code>
as its <code>:flow/to</code>, it must come directly behind an <code>:all</code> condition, or
first if there is no <code>:all</code> condition. This is because of the semantics
of short circuiting. We&#8217;ll discuss what short circuiting means later in
this section.</p>
</div>
<div class="paragraph">
<p><code>:flow/to</code> set to <code>:all</code> or <code>:none</code> must always set
<code>:flow/short-circuit?</code> to <code>true</code>.</p>
</div>
<div class="paragraph">
<p><code>:flow/from</code> may be set to <code>:all</code>. This directs all immediate upstream
links to pass segments to this task&#8217;s flow condition. <code>:flow/from</code> as
<code>:all</code> does not impose order constraints as <code>:flow/to</code> set to <code>:all</code>
does.</p>
</div>
</div>
<div class="sect2">
<h3 id="_short_circuiting"><a class="anchor" href="#_short_circuiting"></a>Short Circuiting</h3>
<div class="paragraph">
<p>If multiple flow condition entries evaluate to a true predicate, their
<code>:flow/to</code> values are unioned (duplicates aren&#8217;t acknowledged), as well
as their <code>:flow/exclude-keys</code>. Sometimes you don&#8217;t want this behavior,
and you want to specify exactly the downstream tasks to emit to - and
not check any more flow condition entries. You can do this with
<code>:flow/short-circuit?</code> set to <code>true</code>. Any entry that has
<code>:flow/short-circuit?</code> set to <code>true</code> must come before any entries for an
task that have it set to <code>false</code> or <code>nil</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Example project:
<a href="https://github.com/onyx-platform/onyx-examples/tree/0.9.x/flow-short-circuit">flow-short-circuit</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_exceptions"><a class="anchor" href="#_exceptions"></a>Exceptions</h3>
<div class="paragraph">
<p>Flow Conditions give you leverage for handling exceptions without miring
your code in <code>try</code>/<code>catch</code> logic. If an exception is thrown from an Onyx
transformation function, you can capture it from within your flow
conditions by setting <code>:flow/thrown-exception?</code> to <code>true</code>. It&#8217;s default
value is <code>false</code>. If an exception is thrown, only flow conditions with
<code>:flow/thrown-exception?</code> set to <code>true</code> will be evaluated. The value
that is normally the segment which is sent to the predicate will be the
exception object that was thrown. Exception flow conditions must have
<code>:flow/short-circuit?</code> set to <code>true</code>. Note that exceptions don&#8217;t
serialize. This feature is meant to be used in conjunction with
Post-transformations and Actions for sending exception values to
downstream tasks.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:flow/from</span> <span class="symbol">:input-stream</span>
 <span class="symbol">:flow/to</span> [<span class="symbol">:error-task</span>]
 <span class="symbol">:flow/short-circuit?</span> <span class="predefined-constant">true</span>
 <span class="symbol">:flow/thrown-exception?</span> <span class="predefined-constant">true</span>
 <span class="symbol">:flow/predicate</span> <span class="symbol">:my.ns/handle-error?</span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the predicate might be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">handle-error?</span> [event old ex-obj all-new]
  (<span class="keyword">=</span> (<span class="keyword">type</span> ex-obj) java.lang.NullPointerException))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will only restrict the flow from <code>:input-stream</code> to <code>:error-task</code>
when an exception is thrown - see the discussion of Short Circuiting
above. When an exception is not thrown, the default behaviour will
apply. For example, if there are later flow conditions, they will apply.
If not will flow through to all tasks if there are no other flow
conditions for that task.</p>
</div>
</div>
<div class="sect2">
<h3 id="_post_transform"><a class="anchor" href="#_post_transform"></a>Post-transform</h3>
<div class="paragraph">
<p>Post-transformations are extension provided to handle segments that
cause exceptions to arise. If a flow condition has
<code>:flow/thrown-exception?</code> set to <code>true</code>, it can also set
<code>:flow/post-transform</code> to a keyword. This keyword must have the value of
a fully namespace qualified function on the classpath. This function
will be invoked with three parameters: the event map, the segment that
caused the exception, and the exception object. The result of this
function, which must be a segment, will be passed to the downstream
tasks. This allows you to come up with a reasonable value to pass
downstream when you encounter an exception, since exceptions don&#8217;t
serialize anyway. <code>:flow/exclude-keys</code> will be called on the resulting
transformed segment.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:flow/from</span> <span class="symbol">:input-stream</span>
 <span class="symbol">:flow/to</span> [<span class="symbol">:error-task</span>]
 <span class="symbol">:flow/short-circuit?</span> <span class="predefined-constant">true</span>
 <span class="symbol">:flow/thrown-exception?</span> <span class="predefined-constant">true</span>
 <span class="symbol">:flow/post-transform</span> <span class="symbol">:my.ns/post-transform</span>
 <span class="symbol">:flow/predicate</span> <span class="symbol">:my.ns/handle-error?</span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And an example post-transform function might be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">post-transform</span> [event segment exception-obj]
  {<span class="symbol">:error</span> <span class="symbol">:my-exception-value</span>})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_actions"><a class="anchor" href="#_actions"></a>Actions</h3>
<div class="paragraph">
<p>After a set of flow conditions has been evaluated for a segment, you
usually want to send the segment downstream to the next set of tasks.
Other times, you want to retry to process the segment because something
went wrong. Perhaps a database connection wasn&#8217;t available, or an email
couldn&#8217;t be sent.</p>
</div>
<div class="paragraph">
<p>Onyx provides Flow Conditions <code>:flow/action</code> to accomplish this. By
setting <code>:flow/action</code> to <code>:retry</code>, a segment will expire from the
internal pool of pending messages and be automatically retried from its
input task. If any of the <code>:flow/action`s from the matching flow
conditions are `:retry</code>, the segment will be retried and <em>will not</em> be
sent downstream. This parameter is optional, and it&#8217;s default value is
<code>nil</code>. <code>nil</code> will cause the segment to be sent to all downstream tasks
that were selected from evaluating the flow conditions. Any flow
condition clauses with <code>:flow/action</code> set to <code>:retry</code> must also have
<code>:flow/short-circuit?</code> set to <code>true</code>, and <code>:flow/to</code> set to <code>:none</code>.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s a quick example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[{<span class="symbol">:flow/from</span> <span class="symbol">:input-stream</span>
  <span class="symbol">:flow/to</span> <span class="symbol">:none</span>
  <span class="symbol">:flow/short-circuit?</span> <span class="predefined-constant">true</span>
  <span class="symbol">:flow/predicate</span> <span class="symbol">:my.ns/adult?</span>
  <span class="symbol">:flow/action</span> <span class="symbol">:retry</span>}

 {<span class="symbol">:flow/from</span> <span class="symbol">:input-stream</span>
  <span class="symbol">:flow/to</span> [<span class="symbol">:task-a</span>]
  <span class="symbol">:flow/predicate</span> <span class="symbol">:my.ns/child?</span>}]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="messaging"><a class="anchor" href="#messaging"></a>Messaging</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_background"><a class="anchor" href="#_background"></a>Background</h3>
<div class="paragraph">
<p>The messaging layer takes care of the direct peer to peer transfer of
segment batches, acks, segment completion and segment retries to the
relevant virtual peers.</p>
</div>
</div>
<div class="sect2">
<h3 id="_messaging_implementations"><a class="anchor" href="#_messaging_implementations"></a>Messaging Implementations</h3>
<div class="paragraph">
<p>The Onyx messaging implementation is pluggable and alternative
implementations can be selected via the <code>:onyx.messaging/impl</code>
<a href="#peer-configuration">Peer Configuration</a> option.</p>
</div>
<div class="sect3">
<h4 id="_aeron_messaging"><a class="anchor" href="#_aeron_messaging"></a>Aeron Messaging</h4>
<div class="paragraph">
<p>Owing to <a href="https://github.com/real-logic/Aeron">Aeron&#8217;s</a> high throughput
and low latency, Aeron is the default Onyx messaging implementation.
There are a few relevant considerations when using the Aeron
implementation.</p>
</div>
<div class="sect4">
<h5 id="_subscription_connection_multiplexing"><a class="anchor" href="#_subscription_connection_multiplexing"></a>Subscription (Connection) Multiplexing</h5>
<div class="paragraph">
<p>One issue when scaling Onyx to a many node cluster is that every
virtual peer may require a communications channel to any other virtual
peer. As a result, a naive implementation will require up to m*m
connections over the cluster, where m is the number of virtual peers.
By sharing Aeron subscribers between virtual peers on a node, this can
be reduced to n*n connections, where n is the number of nodes. This
reduces the amount of overhead required to maintain connections
between peers, allowing the cluster to scale better as the number of
nodes to increase.</p>
</div>
<div class="paragraph">
<p>It is worth noting that Aeron subscribers (receivers) must also
generally perform deserialization. Therefore, subscribers may become
CPU bound by the amount of deserializaton work that needs to be
performed. In order to reduce this effect, multiple subscribers can be
instantiated per node. This can be tuned via
<code>:onyx.messaging.aeron/subscriber-count</code> in <a href="#peer-configuration">Peer
Configuration</a>. As increasing the number of subscribers may lead back
to an undesirable growth in the number of connections between nodes,
each node will only choose one subscription to communicate through.
The choice of subscriber is calculated via a hash of the combined IPs
of the communicating nodes, in order to consistently spread the use of
subscribers over the cluster.</p>
</div>
<div class="paragraph">
<p>Clusters which perform a large proportion of the time serializing
should consider increasing the subscriber count. As a general guide,
<code>cores = virtual peers + subscribers</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_connection_short_circuiting"><a class="anchor" href="#_connection_short_circuiting"></a>Connection Short Circuiting</h5>
<div class="paragraph">
<p>When virtual peers are co-located on the same node, messaging will
bypass the use of Aeron and directly communicate the message without any
use of the network and without any serialization. Therefore, performance
benchmarks performed on a single node can be very misleading.</p>
</div>
<div class="paragraph">
<p>The <a href="#peer-configuration">Peer Configuration</a> option,
<code>:onyx.messaging/allow-short-circuit?</code> is provided for the purposes of
more realistic performance testing on a single node.</p>
</div>
</div>
<div class="sect4">
<h5 id="_port_use"><a class="anchor" href="#_port_use"></a>Port Use</h5>
<div class="paragraph">
<p>The Aeron messaging implementation will use the port configured via
<code>:onyx.messaging/peer-port</code>. This <em>UDP port</em> must be unfirewalled.</p>
</div>
</div>
<div class="sect4">
<h5 id="_media_driver"><a class="anchor" href="#_media_driver"></a>Media Driver</h5>
<div class="paragraph">
<p>Aeron requires a media driver to be used on each node. Onyx provides
an embedded media driver for local testing, however use of the
embedded driver is not recommended in production. The embedded driver
can be configured via the <code>:onyx.messaging.aeron/embedded-driver?</code>
<a href="#peer-configuration">Peer Configuration</a> option.</p>
</div>
<div class="paragraph">
<p>When using Aeron messaging in production, a media driver should be
created in another java process. You can do this via the following code
snippet, or by using the
<a href="https://github.com/real-logic/Aeron=media-driver-packaging">Aeron
distribution</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">your-app.aeron-media-driver</span>
  (<span class="symbol">:require</span> [clojure.core.async <span class="symbol">:refer</span> [chan &lt;!!]])
  (<span class="symbol">:import</span> [uk.co.real_logic.aeron Aeron$Context]
           [uk.co.real_logic.aeron.driver MediaDriver MediaDriver$Context ThreadingMode]))

(<span class="keyword">defn</span> <span class="function">-main</span> [&amp; args]
  (<span class="keyword">let</span> [ctx (<span class="keyword">doto</span> (MediaDriver$Context.))
        media-driver (MediaDriver/launch ctx)]
    (<span class="keyword">println</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Launched the Media Driver. Blocking forever...</span><span class="delimiter">&quot;</span></span>)
    (&lt;!! (chan))))</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_configuration_options"><a class="anchor" href="#_configuration_options"></a>Configuration Options</h5>
<div class="paragraph">
<p>Aeron is independently configurable via Java properties (e.g.
<code>JAVA_OPTS="-Daeron.mtu.length=16384"</code>). Configuration of these may
cause different performance characteristics, and certain options may
need to be configured in order to communicate large segments between
peers.</p>
</div>
<div class="paragraph">
<p>Documentation for these configuration options can be found in
<a href="https://github.com/real-logic/Aeron/wiki/Configuration-Options">Aeron&#8217;s
documentation</a>.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="lifecycles"><a class="anchor" href="#lifecycles"></a>Lifecycles</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Lifecycles are a feature that allow you to control code that executes at
particular points during task execution on each peer. Lifecycles are
data driven and composable.</p>
</div>
<div class="sect2">
<h3 id="_summary_2"><a class="anchor" href="#_summary_2"></a>Summary</h3>
<div class="paragraph">
<p>There are several interesting points to execute arbitrary code during a
task in Onyx. Onyx lets you plug in and calls functions before a task,
after a task, before a batch, and after a batch on every peer.
Additionally, there is another lifecycle hook that allows you to delay
starting a task in case you need to do some work like acquiring a lock
under contention. A peer&#8217;s lifecycle is isolated to itself, and
lifecycles never coordinate across peers. Usage of lifecycles are
entirely optional. Lifecycle data is submitted as a data structure at
job submission time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_lifecycle_phases"><a class="anchor" href="#_lifecycle_phases"></a>Lifecycle Phases</h3>
<div class="sect3">
<h4 id="_before_task_set_up"><a class="anchor" href="#_before_task_set_up"></a>Before task set up</h4>
<div class="paragraph">
<p>A function that takes two arguments - an event map, and the matching
lifecycle map. Must return a boolean value indicating whether to start
the task or not. If false, the process backs off for a preconfigured
amount of time and calls this task again. Useful for lock acquisition.
This function is called prior to any processes inside the task becoming
active.</p>
</div>
</div>
<div class="sect3">
<h4 id="_before_task_execution"><a class="anchor" href="#_before_task_execution"></a>Before task execution</h4>
<div class="paragraph">
<p>A function that takes two arguments - an event map, and the matching
lifecycle map. Must return a map that is merged back into the original
event map. This function is called after processes in the task are
launched, but before the peer listens for incoming segments from other
peers.</p>
</div>
</div>
<div class="sect3">
<h4 id="_before_batch_start"><a class="anchor" href="#_before_batch_start"></a>Before batch start</h4>
<div class="paragraph">
<p>A function that takes two arguments - an event map, and the matching
lifecycle map. Must return a map that is merged back into the original
event map. This function is called prior to receiving a batch of
segments from the reading function.</p>
</div>
</div>
<div class="sect3">
<h4 id="_after_reading_batch_of_segments"><a class="anchor" href="#_after_reading_batch_of_segments"></a>After reading batch of segments</h4>
<div class="paragraph">
<p>A function that takes two arguments - an event map, and the matching
lifecycle map. Must return a map that is merged back into the original
event map. This function is called immediately after a batch of segments
has been read by the peer. The segments are available in the event map
by the key <code>:onyx.core/batch</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_after_apply_fn_batch"><a class="anchor" href="#_after_apply_fn_batch"></a>After apply fn batch</h4>
<div class="paragraph">
<p>A function that takes two arguments - an event map, and the matching
lifecycle map. Must return a map that is merged back into the original
event map. This function is called after the <code>:onyx/fn</code> has been applied to the
input segments and created output segments.</p>
</div>
</div>
<div class="sect3">
<h4 id="_after_batch"><a class="anchor" href="#_after_batch"></a>After batch</h4>
<div class="paragraph">
<p>A function that takes two arguments - an event map, and the matching
lifecycle map. Must return a map that is merged back into the original
event map. This function is called before the peer relinquishes its
task. No more segments will be received.</p>
</div>
</div>
<div class="sect3">
<h4 id="_after_ack_message"><a class="anchor" href="#_after_ack_message"></a>After ack message</h4>
<div class="paragraph">
<p>A function that takes four arguments - an event map, a message id, the
return of an input plugin ack-segment call, and the matching lifecycle
map. May return a value of any type which will be discarded. This
function is called whenever a segment at the input task has been fully acked.</p>
</div>
</div>
<div class="sect3">
<h4 id="_after_retry_message"><a class="anchor" href="#_after_retry_message"></a>After retry message</h4>
<div class="paragraph">
<p>A function that takes four arguments - an event map, a message id, the
return of an input plugin ack-segment call, and the matching lifecycle
map. May return a value of any type which will be discarded. This
function is called whenever a segment at the input task has been pending for
greater than pending-timeout time and will be retried.</p>
</div>
</div>
<div class="sect3">
<h4 id="_handle_exception"><a class="anchor" href="#_handle_exception"></a>Handle Exception</h4>
<div class="paragraph">
<p>If an exception is thrown during any lifecycle execution except
<code>after-task-stop</code>, one or more lifecycle handlers may be defined. If
present, the exception will be caught and passed to this function. See
the details on the
<a href="http://www.onyxplatform.org/docs/cheat-sheet/latest/#lifecycle-calls/:lifecycle/handle-exception">Onyx
cheat sheet</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_example"><a class="anchor" href="#_example"></a>Example</h3>
<div class="paragraph">
<p>Let&#8217;s work with an example to show how lifecycles work. Suppose you want
to print out a message at all the possible lifecycle hooks. You&#8217;d start
by defining 9 functions for the 9 hooks:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">my.ns</span>)

(<span class="keyword">defn</span> <span class="function">start-task?</span> [event lifecycle]
  (<span class="keyword">println</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Executing once before the task starts.</span><span class="delimiter">&quot;</span></span>)
  <span class="predefined-constant">true</span>)

(<span class="keyword">defn</span> <span class="function">before-task-start</span> [event lifecycle]
  (<span class="keyword">println</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Executing once before the task starts.</span><span class="delimiter">&quot;</span></span>)
  {})

(<span class="keyword">defn</span> <span class="function">after-task-stop</span> [event lifecycle]
  (<span class="keyword">println</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Executing once after the task is over.</span><span class="delimiter">&quot;</span></span>)
  {})

(<span class="keyword">defn</span> <span class="function">before-batch</span> [event lifecycle]
  (<span class="keyword">println</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Executing once before each batch.</span><span class="delimiter">&quot;</span></span>)
  {})

(<span class="keyword">defn</span> <span class="function">after-read-batch</span> [event lifecycle]
  (<span class="keyword">println</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Executing once after this batch has been read.</span><span class="delimiter">&quot;</span></span>)
  {})

(<span class="keyword">defn</span> <span class="function">after-apply-fn</span> [event lifecycle]
  (<span class="keyword">println</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Executing once after the onyx/fn has been called on the input segments.</span><span class="delimiter">&quot;</span></span>)
  {})

(<span class="keyword">defn</span> <span class="function">after-batch</span> [event lifecycle]
  (<span class="keyword">println</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Executing once after each batch.</span><span class="delimiter">&quot;</span></span>)
  {})

(<span class="keyword">defn</span> <span class="function">after-ack-segment</span> [event message-id rets lifecycle]
  (<span class="keyword">println</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Message </span><span class="delimiter">&quot;</span></span> message-id <span class="string"><span class="delimiter">&quot;</span><span class="content"> is fully acked</span><span class="delimiter">&quot;</span></span>))

(<span class="keyword">defn</span> <span class="function">after-retry-segment</span> [event message-id rets lifecycle]
  (<span class="keyword">println</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Retrying message </span><span class="delimiter">&quot;</span></span> message-id))

(<span class="keyword">defn</span> <span class="function">handle-exception</span> [event lifecycle lifecycle-phase e]
  (<span class="keyword">println</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Caught exception: </span><span class="delimiter">&quot;</span></span> e)
  (<span class="keyword">println</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Returning :restart, indicating that this task should restart.</span><span class="delimiter">&quot;</span></span>)
  <span class="symbol">:restart</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that all lifecycle functions return maps except <code>start-task?</code>.
This map is merged back into the <code>event</code> parameter that you received.
<code>start-task?</code> is a boolean function that allows you to block and back
off if you don&#8217;t want to start the task quite yet. This function will be
called periodically as long as <code>false</code> is returned. If more than one
<code>start-task?</code> is specified in your lifecycles, they must all return
<code>true</code> for the task to begin. <code>start-task?</code> is invoked <em>before</em>
<code>before-task-start</code>.</p>
</div>
<div class="paragraph">
<p>Next, define a map that wires all these functions together by mapping
predefined keywords to the functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">calls</span>
  {<span class="symbol">:lifecycle/start-task?</span> start-task?
   <span class="symbol">:lifecycle/before-task-start</span> before-task-start
   <span class="symbol">:lifecycle/before-batch</span> before-batch
   <span class="symbol">:lifecycle/after-read-batch</span> after-read-batch
   <span class="symbol">:lifecycle/after-apply-fn</span> after-apply-fn
   <span class="symbol">:lifecycle/after-batch</span> after-batch
   <span class="symbol">:lifecycle/after-task-stop</span> after-task-stop
   <span class="symbol">:lifecycle/after-ack-segment</span> after-ack-segment
   <span class="symbol">:lifecycle/after-retry-segment</span> after-retry-segment
   <span class="symbol">:lifecycle/handle-exception</span> handle-exception})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each of these 9 keys maps to a function. All of these keys are optional,
so you can mix and match depending on which functions you actually need
to use.</p>
</div>
<div class="paragraph">
<p>Finally, create a lifecycle data structure by pointing
<code>:lifecycle/calls</code> to the fully qualified namespaced keyword that
represents the calls map that we just defined. Pass it to your
<code>onyx.api/submit-job</code> call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">lifecycles</span>
  [{<span class="symbol">:lifecycle/task</span> <span class="symbol">:my-task-name-here</span>
    <span class="symbol">:lifecycle/calls</span> <span class="symbol">:my.ns/calls</span>
    <span class="symbol">:lifecycle/doc</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Test lifecycles and print a message at each stage</span><span class="delimiter">&quot;</span></span>}])

(onyx.api/submit-job
  peer-config
  {
  <span class="keyword">..</span><span class="keyword">.</span>
  <span class="symbol">:lifecycles</span> lifecycles
  <span class="keyword">..</span><span class="keyword">.</span>
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to have a lifecycle apply to every task in a
workflow by specifying <code>:lifecycle/task :all</code>. This is useful for
instrumenting your tasks with metrics, error handling, or debugging
information.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">lifecycles</span>
  [{<span class="symbol">:lifecycle/task</span> <span class="symbol">:all</span>
    <span class="symbol">:lifecycle/calls</span> <span class="symbol">:my.ns/add-metrics</span>
    <span class="symbol">:lifecycle/doc</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Instruments all tasks in a workflow with the example function 'add-metrics'</span><span class="delimiter">&quot;</span></span>}])</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can supply as many sets of lifecycles as you want. They are invoked
in the order that they are supplied in the vector, giving you a
predictable sequence of calls. Be sure that all the keyword symbols and
functions are required onto the classpath for the peer that will be
executing them.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Example project:
<a href="https://github.com/onyx-platform/onyx-examples/tree/0.9.x/lifecycles">lifecycles</a>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="windowing-and-aggregation"><a class="anchor" href="#windowing-and-aggregation"></a>Windowing and Aggregation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section discusses a feature called windowing. Windows allow you to
group and accrue data into possibly overlapping buckets. Windows are
intimately related to the Triggers feature. When you&#8217;re finished reading
this section, head over to the Triggers chapter next.</p>
</div>
<div class="sect2">
<h3 id="_summary_3"><a class="anchor" href="#_summary_3"></a>Summary</h3>
<div class="paragraph">
<p>Windowing splits up a possibly unbounded data set into finite, possibly
overlapping portions. Windows allow us create aggregations over distinct
portions of a stream, rather than stalling and waiting for the entire
data data set to arrive. In Onyx, Windows strictly describe how data is
accrued. When you want to <em>do</em> something with the windowed data, you use
a Trigger. See the chapter on Triggers for more information. Onyx&#8217;s
windowing mechanisms are strong enough to handle stream disorder. If
your data arrives in an order that isn&#8217;t "logical" (for example,
<code>:event-time</code> keys moving backwards in time), Onyx can sort out the
appropriate buckets to put the data in.</p>
</div>
</div>
<div class="sect2">
<h3 id="_window_types"><a class="anchor" href="#_window_types"></a>Window Types</h3>
<div class="paragraph">
<p>The topic of windows has been widely explored in the literature. There
are different <em>types</em> of windows. Currently, Onyx supports Fixed,
Sliding, Global, and Session windows. We will now explain the supported
window types.</p>
</div>
<div class="sect3">
<h4 id="_fixed_windows"><a class="anchor" href="#_fixed_windows"></a>Fixed Windows</h4>
<div class="paragraph">
<p>Fixed windows, sometimes called Tumbling windows, span a particular
range and do not slide. That is, fixed windows never overlap one
another. Consequently, a data point will fall into exactly one instance
of a window (often called an <em>extent</em> in the literature). As it turns
out, fixed windows are a special case of sliding windows where the range
and slide values are equal. You can see a visual below of how this
works, where the <code>|--|</code> drawings represent extents. Each window is of
range <code>5</code>. Time runs horizontally, while the right-hand side features
the extent bound running vertically. The first extent captures all
values between 0 and 4.99999&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">1, 5, 10, 15, 20, 25, 30, 35, 40
|--|                                [0  - 4]
   |--|                             [5  - 9]
      |---|                         [10 - 14]
          |---|                     [15 - 19]
              |---|                 [20 - 24]
                  |---|             [25 - 29]
                      |---|         [30 - 34]
                          |---|     [35 - 39]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:window/id</span> <span class="symbol">:collect-segments</span>
 <span class="symbol">:window/task</span> <span class="symbol">:identity</span>
 <span class="symbol">:window/type</span> <span class="symbol">:fixed</span>
 <span class="symbol">:window/aggregation</span> <span class="symbol">:onyx.windowing.aggregation/count</span>
 <span class="symbol">:window/window-key</span> <span class="symbol">:event-time</span>
 <span class="symbol">:window/range</span> [<span class="integer">5</span> <span class="symbol">:minutes</span>]}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Example project:
<a href="https://github.com/onyx-platform/onyx-examples/tree/0.9.x/fixed-windows">fixed-windows</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_sliding_windows"><a class="anchor" href="#_sliding_windows"></a>Sliding Windows</h4>
<div class="paragraph">
<p>In contrast to fixed windows, sliding windows allow extents to overlap.
When a sliding window is specified, we have to give it a range for which
the window spans, and a <em>slide</em> value for how long to wait between
spawning a new window extent. Every data point will fall into exactly
<code>range / slide</code> number of window extents. We draw out what this looks
like for a sliding window with range <code>15</code> and slide <code>5</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">1, 5, 10, 15, 20, 25, 30, 35, 40
|---------|                         [0  - 14]
   |----------|                     [5  - 19]
      |-----------|                 [10 - 24]
          |-----------|             [15 - 29]
              |-----------|         [20 - 34]
                  |-----------|     [25 - 39]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:window/id</span> <span class="symbol">:collect-segments</span>
 <span class="symbol">:window/task</span> <span class="symbol">:identity</span>
 <span class="symbol">:window/type</span> <span class="symbol">:sliding</span>
 <span class="symbol">:window/aggregation</span> <span class="symbol">:onyx.windowing.aggregation/conj</span>
 <span class="symbol">:window/window-key</span> <span class="symbol">:event-time</span>
 <span class="symbol">:window/range</span> [<span class="integer">15</span> <span class="symbol">:minutes</span>]
 <span class="symbol">:window/slide</span> [<span class="integer">5</span> <span class="symbol">:minute</span>]}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Example project:
<a href="https://github.com/onyx-platform/onyx-examples/tree/0.9.x/sliding-windows">sliding-windows</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_global_windows"><a class="anchor" href="#_global_windows"></a>Global Windows</h4>
<div class="paragraph">
<p>Global windows are perhaps the easiest to understand. With global
windows, there is exactly one window extent that match all data that
enters it. This lets you capture events that span over an entire domain
of time. Global windows are useful for modeling batch or timeless
computations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">&lt;- Negative Infinity                Positive Infinity -&gt;
|-------------------------------------------------------|</code></pre>
</div>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:window/id</span> <span class="symbol">:collect-segments</span>
 <span class="symbol">:window/task</span> <span class="symbol">:identity</span>
 <span class="symbol">:window/type</span> <span class="symbol">:global</span>
 <span class="symbol">:window/aggregation</span> <span class="symbol">:onyx.windowing.aggregation/count</span>}]</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Example project:
<a href="https://github.com/onyx-platform/onyx-examples/tree/0.9.x/global-windows">global-windows</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_session_windows"><a class="anchor" href="#_session_windows"></a>Session Windows</h4>
<div class="paragraph">
<p>Session windows are windows that dynamically resize their upper and
lower bounds in reaction to incoming data. Sessions capture a time span
of activity for a specific key, such as a user ID. If no activity occurs
within a timeout gap, the session closes. If an event occurs within the
bounds of a session, the window size is fused with the new event, and
the session is extended by its timeout gap either in the forward or
backward direction.</p>
</div>
<div class="paragraph">
<p>For example, if events with the same session key occured at <code>5</code>, <code>7</code>,
and <code>20</code>, and the session window used a timeout gap of 5, the windows
would look like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">1, 5, 10, 15, 20, 25, 30, 35, 40
   |-|                           [5 - 7]
              |                  [20 - 20]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Windows that aren&#8217;t fused to anything are single points in time (see
<code>20</code>). If an event occurs before or after its timeout gap on the
timeline, the two events fuse, as <code>5</code>, and <code>7</code> do.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:window/id</span> <span class="symbol">:collect-segments</span>
 <span class="symbol">:window/task</span> <span class="symbol">:identity</span>
 <span class="symbol">:window/type</span> <span class="symbol">:session</span>
 <span class="symbol">:window/aggregation</span> <span class="symbol">:onyx.windowing.aggregation/conj</span>
 <span class="symbol">:window/window-key</span> <span class="symbol">:event-time</span>
 <span class="symbol">:window/session-key</span> <span class="symbol">:id</span>
 <span class="symbol">:window/timeout-gap</span> [<span class="integer">5</span> <span class="symbol">:minutes</span>]}]</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Example project:
<a href="https://github.com/onyx-platform/onyx-examples/tree/0.9.x/session-windows">session-windows</a>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_units"><a class="anchor" href="#_units"></a>Units</h3>
<div class="paragraph">
<p>Onyx allows you to specify range and slide values in different
magnitudes of units, so long as the units can be coverted to the same
unit in the end. For example, you can specify the range in minutes, and
the slide in seconds. Any value that requires units takes a vector of
two elements. The first element represents the value, and the second the
unit. For example, window specifications denoting range and slide might
look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:window/range</span> [<span class="integer">1</span> <span class="symbol">:minute</span>]
 <span class="symbol">:window/slide</span> [<span class="integer">30</span> <span class="symbol">:seconds</span>]}</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the information model for all supported units. You can use a
singular form (e.g. <code>:minute</code>) instead of the plural (e.g. <code>:minutes</code>)
where it makes sense for readability.</p>
</div>
<div class="paragraph">
<p>Onyx is also capable of sliding by <code>:elements</code>. This is often referred
to as "slide-by-tuple" in research. Onyx doesn&#8217;t require a time-based
range and slide value. Any totally ordered value will work equivalently.</p>
</div>
</div>
<div class="sect2">
<h3 id="_aggregation"><a class="anchor" href="#_aggregation"></a>Aggregation</h3>
<div class="paragraph">
<p>Windows allow you accrete data over time. Sometimes, you want to store
all the data. Othertimes you want to incrementally compact the data.
Window specifications must provide a <code>:window/aggregation</code> key. We&#8217;ll go
over an example of every type of aggregation that Onyx supports.</p>
</div>
<div class="sect3">
<h4 id="__code_onyx_windowing_aggregation_conj_code"><a class="anchor" href="#__code_onyx_windowing_aggregation_conj_code"></a><code>:onyx.windowing.aggregation/conj</code></h4>
<div class="paragraph">
<p>The <code>:conj</code> aggregation is the simplest. It collects segments for this
window and retains them in a vector, unchanged.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:window/id</span> <span class="symbol">:collect-segments</span>
 <span class="symbol">:window/task</span> <span class="symbol">:identity</span>
 <span class="symbol">:window/type</span> <span class="symbol">:sliding</span>
 <span class="symbol">:window/aggregation</span> <span class="symbol">:onyx.windowing.aggregation/conj</span>
 <span class="symbol">:window/window-key</span> <span class="symbol">:event-time</span>
 <span class="symbol">:window/range</span> [<span class="integer">30</span> <span class="symbol">:minutes</span>]
 <span class="symbol">:window/slide</span> [<span class="integer">5</span> <span class="symbol">:minutes</span>]
 <span class="symbol">:window/doc</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Collects segments on a 30 minute window sliding every 5 minutes</span><span class="delimiter">&quot;</span></span>}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__code_onyx_windowing_aggregation_count_code"><a class="anchor" href="#__code_onyx_windowing_aggregation_count_code"></a><code>:onyx.windowing.aggregation/count</code></h4>
<div class="paragraph">
<p>The <code>:onyx.windowing.aggregation/count</code> operation counts the number of
segments in the window.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:window/id</span> <span class="symbol">:count-segments</span>
 <span class="symbol">:window/task</span> <span class="symbol">:identity</span>
 <span class="symbol">:window/type</span> <span class="symbol">:fixed</span>
 <span class="symbol">:window/aggregation</span> <span class="symbol">:onyx.windowing.aggregation/count</span>
 <span class="symbol">:window/window-key</span> <span class="symbol">:event-time</span>
 <span class="symbol">:window/range</span> [<span class="integer">1</span> <span class="symbol">:hour</span>]
 <span class="symbol">:window/doc</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Counts segments in one hour fixed windows</span><span class="delimiter">&quot;</span></span>}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__code_onyx_windowing_aggregation_sum_code"><a class="anchor" href="#__code_onyx_windowing_aggregation_sum_code"></a><code>:onyx.windowing.aggregation/sum</code></h4>
<div class="paragraph">
<p>The <code>:sum</code> operation adds the values of <code>:age</code> for all segments in the
window.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:window/id</span> <span class="symbol">:sum-ages</span>
 <span class="symbol">:window/task</span> <span class="symbol">:identity</span>
 <span class="symbol">:window/type</span> <span class="symbol">:fixed</span>
 <span class="symbol">:window/aggregation</span> [<span class="symbol">:onyx.windowing.aggregation/sum</span> <span class="symbol">:age</span>]
 <span class="symbol">:window/window-key</span> <span class="symbol">:event-time</span>
 <span class="symbol">:window/range</span> [<span class="integer">1</span> <span class="symbol">:hour</span>]
 <span class="symbol">:window/doc</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Adds the :age key in all segments in 1 hour fixed windows</span><span class="delimiter">&quot;</span></span>}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__code_onyx_windowing_aggregation_min_code"><a class="anchor" href="#__code_onyx_windowing_aggregation_min_code"></a><code>:onyx.windowing.aggregation/min</code></h4>
<div class="paragraph">
<p>The <code>:min</code> operation retains the minimum value found for <code>:age</code>. An
initial value must be supplied via <code>:window/init</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:window/id</span> <span class="symbol">:min-age</span>
 <span class="symbol">:window/task</span> <span class="symbol">:identity</span>
 <span class="symbol">:window/type</span> <span class="symbol">:fixed</span>
 <span class="symbol">:window/aggregation</span> [<span class="symbol">:onyx.windowing.aggregation/min</span> <span class="symbol">:age</span>]
 <span class="symbol">:window/init</span> <span class="integer">100</span>
 <span class="symbol">:window/window-key</span> <span class="symbol">:event-time</span>
 <span class="symbol">:window/range</span> [<span class="integer">30</span> <span class="symbol">:minutes</span>]
 <span class="symbol">:window/doc</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Finds the minimum :age in 30 minute fixed windows, default is 100</span><span class="delimiter">&quot;</span></span>}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__code_onyx_windowing_aggregation_max_code"><a class="anchor" href="#__code_onyx_windowing_aggregation_max_code"></a><code>:onyx.windowing.aggregation/max</code></h4>
<div class="paragraph">
<p>The <code>:max</code> operation retains the maximum value found for <code>:age</code>. An
initial value must be supplied via <code>:window/init</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:window/id</span> <span class="symbol">:max-age</span>
 <span class="symbol">:window/task</span> <span class="symbol">:identity</span>
 <span class="symbol">:window/type</span> <span class="symbol">:fixed</span>
 <span class="symbol">:window/aggregation</span> [<span class="symbol">:onyx.windowing.aggregation/max</span> <span class="symbol">:age</span>]
 <span class="symbol">:window/init</span> <span class="integer">0</span>
 <span class="symbol">:window/window-key</span> <span class="symbol">:event-time</span>
 <span class="symbol">:window/range</span> [<span class="integer">30</span> <span class="symbol">:minutes</span>]
 <span class="symbol">:window/doc</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Finds the maximum :age in 30 minute fixed windows, default is 0</span><span class="delimiter">&quot;</span></span>}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__code_onyx_windowing_aggregation_average_code"><a class="anchor" href="#__code_onyx_windowing_aggregation_average_code"></a><code>:onyx.windowing.aggregation/average</code></h4>
<div class="paragraph">
<p>The <code>:average</code> operation maintains an average over <code>:age</code>. The state is
maintained as a map with three keys - <code>:n</code>, the number of elements, <code>:sum</code>, the running sum,
and <code>:average</code>, the running average.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:window/id</span> <span class="symbol">:average-age</span>
 <span class="symbol">:window/task</span> <span class="symbol">:identity</span>
 <span class="symbol">:window/type</span> <span class="symbol">:fixed</span>
 <span class="symbol">:window/aggregation</span> [<span class="symbol">:onyx.windowing.aggregation/average</span> <span class="symbol">:age</span>]
 <span class="symbol">:window/window-key</span> <span class="symbol">:event-time</span>
 <span class="symbol">:window/range</span> [<span class="integer">30</span> <span class="symbol">:minutes</span>]
 <span class="symbol">:window/doc</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Finds the average :age in 30 minute fixed windows, default is 0</span><span class="delimiter">&quot;</span></span>}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__code_onyx_windowing_aggregation_collect_by_key_code"><a class="anchor" href="#__code_onyx_windowing_aggregation_collect_by_key_code"></a><code>:onyx.windowing.aggregation/collect-by-key</code></h4>
<div class="paragraph">
<p>The <code>:collect-by-key</code> operation maintains a collection of all segments
with a common key.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:window/id</span> <span class="symbol">:collect-members</span>
 <span class="symbol">:window/task</span> <span class="symbol">:identity</span>
 <span class="symbol">:window/type</span> <span class="symbol">:fixed</span>
 <span class="symbol">:window/aggregation</span> [<span class="symbol">:onyx.windowing.aggregation/collect-by-key</span> <span class="symbol">:team</span>]
 <span class="symbol">:window/window-key</span> <span class="symbol">:event-time</span>
 <span class="symbol">:window/range</span> [<span class="integer">30</span> <span class="symbol">:minutes</span>]
 <span class="symbol">:window/doc</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Collects all users on the same :team in 30 minute fixed windows</span><span class="delimiter">&quot;</span></span>}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_grouping"><a class="anchor" href="#_grouping"></a>Grouping</h4>
<div class="paragraph">
<p>All of the above aggregates have slightly different behavior when
<code>:onyx/group-by-key</code> or <code>:onyx/group-by-fn</code> are specified on the catalog
entry. Instead of the maintaining a scalar value in the aggregate, Onyx
maintains a map. The keys of the map are the grouped values, and values
of the map are normal scalar aggregates.</p>
</div>
<div class="paragraph">
<p>For example, if you had the catalog entry set to <code>:onyx/group-by-key</code>
with value <code>:name</code>, and you used a window aggregate of
<code>:onyx.windowing.aggregation/count</code>, and you sent through segments
<code>[{:name "john"} {:name "tiffany"} {:name "john"}]</code>, the aggregate map
would look like <code>{"john" 2 "tiffany" 1}</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_window_specification"><a class="anchor" href="#_window_specification"></a>Window Specification</h3>
<div class="paragraph">
<p>See the Information Model chapter for an exact specification of what
values the Window maps need to supply. Here we will describe what each
of the keys mean.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">key name</th>
<th class="tableblock halign-left valign-top">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:window/id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unique identifier per window</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:window/task</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The workflow task over which the window operates</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:window/type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Which type of window this is (fixed, sliding, etc)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:window/aggregation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The aggregation function to apply, as described
above. If this operation is over a key, this is a vector, with the
second element being the key.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:window/window-key</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The key over which the range will be calculated</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:window/range</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The span of the window</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:window/slide</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The delay to wait to start a new window after the
previous window</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:window/init</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The initial value required for some types of
aggregation</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:window/min-value</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A strict mininum value that <code>:window/window-key</code>
can ever be, default is 0.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:window/doc</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An optional docstring explaining the window&#8217;s purpose</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="triggers"><a class="anchor" href="#triggers"></a>Triggers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section, we talk about Triggers. Triggers are a feature that
interact with <em>Windows</em>. Windows capture and bucket data over time.
Triggers let you release the captured data over a variety stimuli.</p>
</div>
<div class="sect2">
<h3 id="_summary_4"><a class="anchor" href="#_summary_4"></a>Summary</h3>
<div class="paragraph">
<p>Windows capture data over time and place segments into discrete,
possibly overlapping buckets. By itself, this is a relatively useless
concept. In order to harness the information that has been captured and
rolled up, we need to <em>move</em> it somewhere. Triggers let us interact with
the state in each extent of a window.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Example project:
<a href="https://github.com/onyx-platform/onyx-examples/tree/master/aggregation">aggregation</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_trigger_types"><a class="anchor" href="#_trigger_types"></a>Trigger Types</h3>
<div class="paragraph">
<p>Onyx ships a number of trigger implementations that can be used out of
the box. Each trigger fires in response to a particular stimulous. All
triggers implemented in Onyx core fire at task completion. We outline
each here and show an example of each in action.</p>
</div>
<div class="sect3">
<h4 id="__code_timer_code"><a class="anchor" href="#__code_timer_code"></a><code>:timer</code></h4>
<div class="paragraph">
<p>This trigger sleeps for a duration of <code>:trigger/period</code>. When it is done
sleeping, the <code>:trigger/sync</code> function is invoked with its usual
arguments. The trigger goes back to sleep and repeats itself.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:trigger/window-id</span> <span class="symbol">:collect-segments</span>
 <span class="symbol">:trigger/refinement</span> <span class="symbol">:onyx.refinements/discarding</span>
 <span class="symbol">:trigger/on</span> <span class="symbol">:onyx.triggers/timer</span>
 <span class="symbol">:trigger/period</span> [<span class="integer">3</span> <span class="symbol">:seconds</span>]
 <span class="symbol">:trigger/sync</span> <span class="symbol">::write-to-dynamo</span>
 <span class="symbol">:trigger/doc</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Writes state to DynamoDB every 5 seconds, discarding intermediate state</span><span class="delimiter">&quot;</span></span>}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__code_segment_code"><a class="anchor" href="#__code_segment_code"></a><code>:segment</code></h4>
<div class="paragraph">
<p>Trigger wakes up in reaction to a new segment being processed. Trigger
only fires once every <code>:trigger/threshold</code> segments. When the threshold
is exceeded, the count of new segments goes back to <code>0</code>, and the looping
proceeds again in the same manner.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:trigger/window-id</span> <span class="symbol">:collect-segments</span>
 <span class="symbol">:trigger/refinement</span> <span class="symbol">:onyx.refinements/accumulating</span>
 <span class="symbol">:trigger/on</span> <span class="symbol">:onyx.triggers/segment</span>
 <span class="symbol">:trigger/fire-all-extents?</span> <span class="predefined-constant">true</span>
 <span class="symbol">:trigger/threshold</span> [<span class="integer">5</span> <span class="symbol">:elements</span>]
 <span class="symbol">:trigger/sync</span> <span class="symbol">::write-to-stdout</span>
 <span class="symbol">:trigger/doc</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Writes the window contents to stdout every 5 segments</span><span class="delimiter">&quot;</span></span>}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__code_punctuation_code"><a class="anchor" href="#__code_punctuation_code"></a><code>:punctuation</code></h4>
<div class="paragraph">
<p>Trigger wakes up in reaction to a new segment being processed. Trigger
only fires if <code>:trigger/pred</code> evaluates to <code>true</code>. The signature of
<code>:trigger/pred</code> is of arity-2: <code>trigger, state-event</code>. Punctuation
triggers are often useful to send signals through that indicate that
no more data will be coming through for a particular window of time.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:trigger/window-id</span> <span class="symbol">:collect-segments</span>
 <span class="symbol">:trigger/refinement</span> <span class="symbol">:onyx.refinements/discarding</span>
 <span class="symbol">:trigger/on</span> <span class="symbol">:onyx.triggers/punctuation</span>
 <span class="symbol">:trigger/pred</span> <span class="symbol">::trigger-pred</span>
 <span class="symbol">:trigger/sync</span> <span class="symbol">::write-to-stdout</span>
 <span class="symbol">:trigger/doc</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Writes the window contents to std out if :trigger/pred is true for this segment</span><span class="delimiter">&quot;</span></span>}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__code_watermark_code"><a class="anchor" href="#__code_watermark_code"></a><code>:watermark</code></h4>
<div class="paragraph">
<p>Trigger wakes up in reaction to a new segment being processed. Trigger
only fires if the value of <code>:window/window-key</code> in the segment exceeds
the upper-bound in the extent of an active window. This is a shortcut
function for a punctuation trigger that fires when any piece of data
has a time-based window key that is above another extent, effectively
declaring that no more data for earlier windows will be arriving.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:trigger/window-id</span> <span class="symbol">:collect-segments</span>
 <span class="symbol">:trigger/refinement</span> <span class="symbol">:onyx.refinements/discarding</span>
 <span class="symbol">:trigger/on</span> <span class="symbol">:onyx.triggers/watermark</span>
 <span class="symbol">:trigger/sync</span> <span class="symbol">::write-to-stdout</span>
 <span class="symbol">:trigger/doc</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Writes the window contents to stdout when this window's watermark has been exceeded</span><span class="delimiter">&quot;</span></span>}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__code_percentile_watermark_code"><a class="anchor" href="#__code_percentile_watermark_code"></a><code>:percentile-watermark</code></h4>
<div class="paragraph">
<p>Trigger wakes up in reaction to a new segment being processed. Trigger
only fires if the value of <code>:window/window-key</code> in the segment exceeds
the lower-bound plus the percentage of the range as indicated by
<code>:trigger/watermark-percentage</code>, a <code>double</code> greater than <code>0</code> and less
than <code>1</code>. This is an alternative to <code>:watermark</code> that allows you to
trigger on <em>most</em> of the data arriving, not necessarily every last
bit.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:trigger/window-id</span> <span class="symbol">:collect-segments</span>
 <span class="symbol">:trigger/refinement</span> <span class="symbol">:onyx.refinements/discarding</span>
 <span class="symbol">:trigger/on</span> <span class="symbol">:onyx.triggers/percentile-watermark</span>
 <span class="symbol">:trigger/watermark-percentage</span> <span class="float">0.95</span>
 <span class="symbol">:trigger/sync</span> <span class="symbol">::write-to-stdout</span>
 <span class="symbol">:trigger/doc</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Writes the window contents to stdout when this window's watermark is exceeded by 95% of its range</span><span class="delimiter">&quot;</span></span>}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_refinement_modes"><a class="anchor" href="#_refinement_modes"></a>Refinement Modes</h3>
<div class="paragraph">
<p>A refinement mode allows you to articulate what should happen to the
state of a window extent after a trigger has been invoked.</p>
</div>
<div class="sect3">
<h4 id="__code_accumulating_code"><a class="anchor" href="#__code_accumulating_code"></a><code>:accumulating</code></h4>
<div class="paragraph">
<p>Setting <code>:trigger/refinement</code> to <code>:onyx.refinements/accumulating</code> means
that the state of a window extent is maintained exactly as is after the
trigger invocation. This is useful if you want to an answer to a query
to "become more correct over time".</p>
</div>
</div>
<div class="sect3">
<h4 id="__code_discarding_code"><a class="anchor" href="#__code_discarding_code"></a><code>:discarding</code></h4>
<div class="paragraph">
<p>Setting <code>:trigger/refinement</code> to <code>:onyx.refinements/discarding</code> means
that the state of a window extent is set back to the value it was
initialized with after the trigger invocation. You&#8217;d want to use this if
the results from one periodic update bear no connection to subsequent
updates.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_syncing"><a class="anchor" href="#_syncing"></a>Syncing</h3>
<div class="paragraph">
<p>Onyx offers you the ultimate flexibility on what to do with your state
during a trigger invocation. Set <code>:trigger/sync</code> to a fully qualified,
namespaced keyword pointing to a function on the classpath at runtime.
This function takes 5 arguments: The
<a href="http://www.onyxplatform.org/docs/cheat-sheet/latest/#/event-map">event
map</a>, the
<a href="http://www.onyxplatform.org/docs/cheat-sheet/latest/#/window-entry">window
map</a> that this trigger is defined on, the
<a href="http://www.onyxplatform.org/docs/cheat-sheet/latest/#/trigger-entry">trigger
map</a>, a
<a href="http://www.onyxplatform.org/docs/cheat-sheet/latest/#/state-event">state-event
map</a>, and the window state as an immutable value. Its return value is
ignored.</p>
</div>
<div class="paragraph">
<p>This function is invoked when the trigger fires, and is used to do any
arbitrary action with the window contents, such as sync them to a
database. It is called once <em>per window instance</em>. In other words, if
a fixed window exists with 5 instances, the firing of a Timer trigger
will call the sync function 5 times. You can use lifecycles to supply
any stateful connections necessary to sync your data. Supplied values
from lifecycles will be available through the first parameter - the
event map.</p>
</div>
</div>
<div class="sect2">
<h3 id="_trigger_specification"><a class="anchor" href="#_trigger_specification"></a>Trigger Specification</h3>
<div class="paragraph">
<p>See the Information Model chapter for an exact specification of what
values the Trigger maps need to supply. Here we will describe what each
of the keys mean.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">key name</th>
<th class="tableblock halign-left valign-top">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:trigger/window-id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A <code>:window/id</code> specified in the collection of
windows.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:trigger/refinement</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fully qualified namespaced keyword for the mode
of refinement e.g. <code>:onyx.refinements/accumlating</code>,
<code>:onyx.refinements/discarding</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:trigger/on</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fully qualified namespaced keyword for the trigger
called to determine whether to fire as a reaction e.g.
<code>:onyx.triggers/segment</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:trigger/sync</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fully qualified namespaced keyword of a function to
call with the state.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:trigger/fire-all-extents?</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When true, fires every extent of a window
in response to a trigger.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:trigger/doc</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An optional docstring explaining the trigger&#8217;s purpose.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aggregation-state-management"><a class="anchor" href="#aggregation-state-management"></a>Aggregation &amp; State Management</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section discusses state management and fault tolerance used in
windowing/streaming joins.</p>
</div>
<div class="sect2">
<h3 id="summary"><a class="anchor" href="#summary"></a>Summary</h3>
<div class="paragraph">
<p>Onyx provides the ability to perform updates to a state machine for
segments which are calculated over <a href="#windowing-and-aggregation">windows</a>. For example, a grouping task may accumulate incoming values
for a number of keys over windows of 5 minutes. This feature is
commonly used for aggregations, such as summing values, though it can
be used to build more complex state machines.</p>
</div>
</div>
<div class="sect2">
<h3 id="state-example"><a class="anchor" href="#state-example"></a>State Example</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">;; Task definition</span>
{<span class="symbol">:onyx/name</span> <span class="symbol">:sum-all-ages</span>
 <span class="symbol">:onyx/fn</span> <span class="symbol">:clojure.core/identity</span>
 <span class="symbol">:onyx/type</span> <span class="symbol">:function</span>
 <span class="symbol">:onyx/group-by-key</span> <span class="symbol">:name</span>
 <span class="symbol">:onyx/flux-policy</span> <span class="symbol">:recover</span>
 <span class="symbol">:onyx/min-peers</span> <span class="integer">2</span>
 <span class="symbol">:onyx/batch-size</span> <span class="integer">20</span>}

<span class="comment">;; Window definition</span>
{<span class="symbol">:window/id</span> <span class="symbol">:sum-all-ages-window</span>
 <span class="symbol">:window/task</span> <span class="symbol">:sum-all-ages</span>
 <span class="symbol">:window/type</span> <span class="symbol">:global</span>
 <span class="symbol">:window/aggregation</span> [<span class="symbol">:your-sum-ns/sum</span> <span class="symbol">:age</span>]
 <span class="symbol">:window/doc</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Adds the :age key in all segments in a global window.</span><span class="delimiter">&quot;</span></span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As segments are processed, an internal state within the calculated
window is updated. In this case we are trying to sum the ages of the
incoming segments.</p>
</div>
<div class="paragraph">
<p>Window aggregations are defined by a map containing the following keys:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">Optional?</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:aggregation/init</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fn (window) to initialise the state.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:aggregation/create-state-update</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fn (window, state, segment) to generate a serializable state machine update.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:aggregation/apply-state-update</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fn (window, state, entry) to apply state machine update entry to a state.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:aggregation/super-aggregation-fn</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fn (window, state-1, state-2) to combine two states in the case of two windows being merged.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>In the <code>:window/aggregation</code> map in the <code>:sum-all-ages</code> window
referenced above.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">your-sum-ns</span>)

(<span class="keyword">defn</span> <span class="function">sum-init-fn</span> [window]
  <span class="integer">0</span>)

(<span class="keyword">defn</span> <span class="function">sum-aggregation-fn</span> [window state segment]
  <span class="comment">; k is :age</span>
  (<span class="keyword">let</span> [k (<span class="keyword">second</span> (<span class="symbol">:window/aggregation</span> window))]
    [<span class="symbol">:set-value</span> (<span class="keyword">+</span> state (<span class="keyword">get</span> segment k))]))

(<span class="keyword">defn</span> <span class="function">sum-application-fn</span> [window state [changelog-type value]]
  (<span class="keyword">case</span> changelog-type
    <span class="symbol">:set-value</span> value))

<span class="comment">;; sum aggregation referenced in window definition.</span>
(<span class="keyword">def</span> <span class="function">sum</span>
  {<span class="symbol">:aggregation/init</span> sum-init-fn
   <span class="symbol">:aggregation/create-state-update</span> sum-aggregation-fn
   <span class="symbol">:aggregation/apply-state-update</span> sum-application-fn})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s try processing some example segments using this aggregation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">John</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">49</span>}
 {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Madeline</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">55</span>}
 {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Geoffrey</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">14</span>}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Results in the following events:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Action</th>
<th class="tableblock halign-left valign-top">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initial state</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Incoming segment</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{:name "John" :age 49}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Changelog entry</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>[:set-value 49]</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applied to state</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>49</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Incoming segment</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{:name "Madeline" :age 55}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Changelog entry</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>[:set-value 104]</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applied to state</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>104</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Incoming segment</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{:name "Geoffrey" :age 14}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Changelog entry</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>[:set-value 128]</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applied to state</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>128</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>This state can be emitted via triggers or another mechanism. By
describing changelog updates as a vector with a log command, such as
<code>:set-value</code> aggregation function can emit multiple types of state
transition if necessary.</p>
</div>
</div>
<div class="sect2">
<h3 id="fault-tolerance"><a class="anchor" href="#fault-tolerance"></a>Fault Tolerance</h3>
<div class="paragraph">
<p>To allow for full recovery after peer crashes, the window state must be
replicated somewhere. As state updates occur, Onyx publishes the stream
of changelog updates to a replicated log.</p>
</div>
<div class="paragraph">
<p>After the changelog entry is written to the replicated log, the segment
is acked, ensuring that a segment is only cleared from the input source
after the update to window states it caused has been fully written to
the log. When a peer crash occurs, a new peer will be assigned to the
task, and this peer will play back all of the changelog entries, and
apply them to the state, starting with the initial state. As the
changelog updates are read back in the same order that they were
written, the full state will be recovered. Partial updates ensure that
only minimal update data is written for each segment processed, while
remaining correct on peer failure.</p>
</div>
</div>
<div class="sect2">
<h3 id="exactly-once-aggregation-updates"><a class="anchor" href="#exactly-once-aggregation-updates"></a>Exactly Once Aggregation Updates</h3>
<div class="paragraph">
<p>Exactly once aggregation updates are supported via Onyx&#8217;s filtering
feature. When a task&#8217;s catalog has <code>:onyx/uniqueness-key</code> set, this key
is looked up in the segment and used as an ID key to determine whether
the segment has been seen before. If it has previously been processed,
and state updates have been persisted, then the segment is not
re-processed. This key is persisted to the state log transactionally
with the window changelog updates, so that previously seen keys can be
recovered in case of a peer failure.</p>
</div>
<div class="paragraph">
<p><strong>See the section "Exactly Once Side-Effects" for discussion of why
side-effects are impossible to achieve Exactly Once</strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="considerations"><a class="anchor" href="#considerations"></a>Considerations</h3>
<div class="paragraph">
<p>In order to reduce memory consumption, uniqueness-key values are
persisted to a local database, currently implemented with RocksDB. This
database uses a bloom filter, and a memory cache, allowing Onyx to avoid
hitting disk for most filter key checks.</p>
</div>
<div class="paragraph">
<p>In order to prevent unbounded increase in the size of the filter&#8217;s disk
consumption, uniqueness-key values are bucketed based on recency, and
the oldest bucket is expired as the newest is filled.</p>
</div>
<div class="paragraph">
<p>Several configuration parameters are available for the rocksdb based
local filter. The most relevant of these for general configuration is
<code>:onyx.rocksdb.filter/num-ids-per-bucket</code>, and
<code>:onyx.rocksdb.num-buckets</code>, which are the size and the number of
buckets referenced above.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Parameter</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:onyx.rocksdb.filter/peer-block-cache-size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RocksDB block cache size
in bytes. Larger caches reduce the chance that the peer will need to
check for the prescence of a uniqueness key on disk. Defaults to 100MB.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">104857600</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:onyx.rocksdb.filter/bloom-filter-bits</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number of bloom filter bits
to use per uniqueness key value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:onyx.rocksdb.filter/num-ids-per-bucket</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number of uniqueness key
values that can exist in a RocksDB filter bucket.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:onyx.rocksdb.filter/num-buckets</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number of rotating filter buckets
to use. Buckets are rotated every
<code>:onyx.rocksdb.filter/num-ids-per-bucket</code>, with the oldest bucket being
discarded if num-buckets already exist.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:onyx.rocksdb.filter/block-size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RocksDB block size. May worth being
tuned depending on the size of your uniqueness-key values.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4096</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:onyx.rocksdb.filter/compression</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether to use compression in
rocksdb filter. It is recommended that <code>:none</code> is used unless your
uniqueness keys are large and compressible.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:none</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:onyx.rocksdb.filter/base-dir</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Temporary directory to persist
uniqueness filtering data.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/tmp/rocksdb_filter</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="exactly-once-side-effects"><a class="anchor" href="#exactly-once-side-effects"></a>Exactly Once Side-Effects</h3>
<div class="paragraph">
<p>Exactly once <em>side-effects</em> resulting from a segment being processed may
occur, as exactly once side-effects are impossible to achieve. Onyx
guarantees that a window state updates resulting from a segment are
perfomed exactly once, however any side-effects that occur as a result
of the segment being processed cannot be guaranteed to only occur once.</p>
</div>
</div>
<div class="sect2">
<h3 id="bookkeeper-implementation"><a class="anchor" href="#bookkeeper-implementation"></a>BookKeeper Implementation</h3>
<div class="paragraph">
<p>State update changelog entries are persisted to BookKeeper, a replicated
log server. An embedded BookKeeper server is included with Onyx. You can
either use the embedded or run BookKeeper along side Onyx in a separate
process.</p>
</div>
<div class="paragraph">
<p>BookKeeper ensures that changelog entries are replicated to multiple
nodes, allowing for the recovery of windowing states upon the crash of a
windowed task.</p>
</div>
<div class="paragraph">
<p>By default the the Onyx BookKeeper replication is striped to 3
BookKeeper instances (the quorum), and written to 3 instances (the
ensemble).</p>
</div>
</div>
<div class="sect2">
<h3 id="running-the-embedded-bookkeeper-server"><a class="anchor" href="#running-the-embedded-bookkeeper-server"></a>Running the embedded BookKeeper server</h3>
<div class="paragraph">
<p>The embedded BookKeeper server can be started via the
<code>onyx.api/start-env</code> api call, with an env-config where
<code>:onyx.bookkeeper/server?</code> is <code>true</code>.</p>
</div>
<div class="paragraph">
<p>When running on a single node, you may wish to use BookKeeper without
starting the multiple instances of BookKeeper required to meet the
ensemble and quorum requirements. In this case you may start a local
quorum (3) of BookKeeper servers by setting
<code>:onyx.bookkeeper/local-quorum?</code> to <code>true</code>.</p>
</div>
<div id="embedded-bookkeeper-configuration-parameters" class="paragraph">
<p>Embedded BookKeeper Configuration Parameters</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Parameter</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:onyx.bookkeeper/server?</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bool to denote whether to startup a
BookKeeper instance on this node, for use in persisting Onyx state
information.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:onyx.bookkeeper/base-ledger-dir</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Directory to store BookKeeper&#8217;s
ledger in. It is recommended that this is altered to somewhere fast,
preferably on a different disk to the BookKeeper jou ral</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/tmp/bookkeeper_ledge</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:onyx.bookkeeper/port</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Port to startup this node&#8217;s BookKeeper
instance on.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>3196</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:onyx.bookkeeper/local-quorum-ports</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ports to use for the local
BookKeeper quorum.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>[3196 3197 3198]</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:onyx.bookkeeper/base-journal-dir</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Directory to store BookKeeper&#8217;s
journal in. It is recommended that this is altered to somewhere fast,
preferably on a different disk to the BookKeeper le der.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/tmp/bookkeeper_journal</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:onyx.bookkeeper/local-quorum?</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bool to denote whether to startup a
full quorum of BookKeeper instances on this node. <strong>Important: for TEST
purposes only.</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="state-log-compaction"><a class="anchor" href="#state-log-compaction"></a>State Log Compaction</h3>
<div class="paragraph">
<p>It is recommended that the state changelog is periodically compacted.
When compaction occurs, the current state is written to a new ledger and
all previous ledgers are swapped for the new compacted state ledger.</p>
</div>
<div class="paragraph">
<p>Compaction can currently only be performed within a task lifecycle for
the windowed task. Be careful to choose the condition (see
<code>YOUR-CONDITION</code> in the example below, as compacting too often is likely
expensive. Compacting once every X segments is reasonable good choice of
condition.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">compaction-lifecycle</span>
    {<span class="symbol">:lifecycle/before-batch</span>
     (<span class="keyword">fn</span> [event lifecycle]
      (<span class="keyword">when</span> YOUR-CONDITION
        (state-extensions/compact-log (<span class="symbol">:onyx.core/state-log</span> event) event @(<span class="symbol">:onyx.core/window-state</span> event)))
      {})})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="bookkeeper-implementation-configuration"><a class="anchor" href="#bookkeeper-implementation-configuration"></a>BookKeeper Implementation Configuration</h3>
<div class="paragraph">
<p>The BookKeeper state log implementation can be configured via the
peer-config. Of particular note, is <code>:onyx.bookkeeper/ledger-password</code>
which generally be changed to a more secure default.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Parameter</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:onyx.bookkeeper/read-batch-size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number of bookkeeper ledger
entries to read at a time when recovering state. Effective batch read of
state entries is write-batch-size * read-batch-si z.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">50</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:onyx.bookkeeper/ledger-id-written-back-off</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number of milliseconds
to back off (sleep) after writing BookKeeper ledger id to the replica.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">50</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:onyx.bookkeeper/ledger-password</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Password to use for Onyx state
persisted to BookKeeper ledgers. Highly recommended this is changed on
cluster wide basis.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INSECUREDEFAULTPASSWORD</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:onyx.bookkeeper/client-throttle</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tunable write throttle for
BookKeeper ledgers.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">30000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:onyx.bookkeeper/write-buffer-size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Size of the buffer to which
BookKeeper ledger writes are buffered via.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:onyx.bookkeeper/client-timeout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BookKeeper client timeout.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">60000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:onyx.bookkeeper/write-batch-size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number of state persistence
writes to batch into a single BookKeeper ledger entry.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:onyx.bookkeeper/ledger-quorum-size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The number of BookKeeper
instances over which entries will be written to. For example, if you
have an ledger-ensemble-size of 3, and a ledger-quorum-s ie of 2, the
first write will be written to server1 and server2, the second write
will be written to server2, and server3, etc.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:onyx.bookkeeper/ledger-ensemble-size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The number of BookKeeper
instances over which entries will be striped. For example, if you have
an ledger-ensemble-size of 3, and a ledger-quorum-size o 2, the first
write will be written to server1 and server2, the second write will be
written to server2, and server3, etc.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:onyx.bookkeeper/write-batch-timeout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maximum amount of time to
wait while batching BookKeeper writes, before writing the batch to
BookKeeper. In case of a full batch read, timeout will no tbe hit.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">50</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="resume-point"><a class="anchor" href="#resume-point"></a>Resume Points</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Resume Points is an Onyx feature used to transfer state between jobs.</p>
</div>
<div class="sect2">
<h3 id="_motivation"><a class="anchor" href="#_motivation"></a>Motivation</h3>
<div class="paragraph">
<p>Onyx jobs maintain valuable state as they run. Such state includes the state of
task windows, triggers, the offset an input task (for example Kafka topics) has
read up to, etc. Onyx&#8217;s design enforces immutable jobs, which cannot be updated
live. Given that production operations often require long running streaming
jobs to be updated/redeployed, there needs to be a way to transition consitent
state snapshots from job to job. Resume points is a data defined mapping
between input and state checkpoints stored by killed/running/completed jobs to
allow window contents, trigger contents and input offsets to be resumed in
newly submitted jobs.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resume_point_definition"><a class="anchor" href="#_resume_point_definition"></a>Resume Point Definition</h3>
<div class="paragraph">
<p>A resume point takes the following form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:my-input-task</span> {<span class="symbol">:input</span> {<span class="symbol">:mode</span> <span class="symbol">:resume</span>
                         <span class="symbol">:task-id</span> <span class="symbol">:src-input-task</span>
                         <span class="symbol">:replica-version</span> <span class="integer">4</span>
                         <span class="symbol">:epoch</span> <span class="integer">4</span>
                         <span class="symbol">:tenancy-id</span> <span class="error">#</span>uuid <span class="string"><span class="delimiter">&quot;</span><span class="content">3b30664d-b442-d55b-c80b-979f9b7df12a</span><span class="delimiter">&quot;</span></span>
                         <span class="symbol">:job-id</span> <span class="error">#</span>uuid <span class="string"><span class="delimiter">&quot;</span><span class="content">2d6fe8f3-f911-fd21-2db9-471d41fbe15b</span><span class="delimiter">&quot;</span></span>
                         <span class="symbol">:slot-migration</span> <span class="symbol">:direct</span>}}
 <span class="symbol">:windowed-task</span> {<span class="symbol">:windows</span> {<span class="symbol">:my-window-1</span>
                            {<span class="symbol">:mode</span> <span class="symbol">:resume</span>
                             <span class="symbol">:replica-version</span> <span class="integer">4</span>
                             <span class="symbol">:epoch</span> <span class="integer">4</span>
                             <span class="symbol">:tenancy-id</span> <span class="error">#</span>uuid <span class="string"><span class="delimiter">&quot;</span><span class="content">3b30664d-b442-d55b-c80b-979f9b7df12a</span><span class="delimiter">&quot;</span></span>
                             <span class="symbol">:job-id</span> <span class="error">#</span>uuid <span class="string"><span class="delimiter">&quot;</span><span class="content">2d6fe8f3-f911-fd21-2db9-471d41fbe15b</span><span class="delimiter">&quot;</span></span>
                             <span class="symbol">:task-id</span> <span class="symbol">:src-windowed-task</span>
                             <span class="symbol">:window-id</span> <span class="symbol">:collect-segments</span>
                             <span class="symbol">:slot-migration</span> <span class="symbol">:direct</span>}}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each task with input checkpoint state, or window state must include a direct
mapping from a previous job. The format of resume points is purposefully
verbose, in order to allow a job to resume state from multiple jobs, split a
large job into multiple smaller jobs, rename tasks, etc. Note, that windowed
input tasks may define both :input and :windows keys in their resume point.</p>
</div>
<div class="paragraph">
<p>The resume point should then supplied with the job, via the <code>:resume-point</code> key
in the job map.</p>
</div>
<div class="paragraph">
<p>Failure modes: if a resume point is supplied, and any task, or task window does
not contain a resume definition, <code>onyx.api/submit-job</code> will fail to validate
the job. If a window is supplied with a resume point, and the resume point does
not contain that window, the job will be killed at run-time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resume_point_modes"><a class="anchor" href="#_resume_point_modes"></a>Resume Point Modes</h3>
<div class="paragraph">
<p>Each input and window resume definition can use one of different modes. The
first mode is <code>:resume</code> as demonstrated above. <code>:resume</code> mode requires snapshot
coordinates be supplied as part of the definition. The second type is <code>{:mode :initialize}</code>,
which when supplied (without any other keys), will initialize the input or
window state as if there was no state to resume from. This is useful when
adding new tasks or windows to your job, as all tasks with input or window
state must account for all their resume definitions in order to submit.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resume_point_helpers"><a class="anchor" href="#_resume_point_helpers"></a>Resume Point Helpers</h3>
<div class="paragraph">
<p>Often the verbose form of the resume point is more specific than we really
need, especially if the job is a direct resume of a job with the same
definitions, backed by different underlying code. Therefore, Onyx supplies some
APIs to improve the usability of resume points.</p>
</div>
<div class="paragraph">
<p>Given the snapshot coordinates:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">---
(<span class="keyword">def</span> <span class="function">snapshot-coordinates</span>
 {<span class="symbol">:tenancy-id</span> <span class="error">#</span>uuid <span class="string"><span class="delimiter">&quot;</span><span class="content">1e5d841a-a77e-00c4-4758-b89c416c58ce</span><span class="delimiter">&quot;</span></span>
  <span class="symbol">:job-id</span> <span class="error">#</span>uuid <span class="string"><span class="delimiter">&quot;</span><span class="content">9dd7b8f8-9854-40d7-8d93-2d205a1a2226</span><span class="delimiter">&quot;</span></span>
  <span class="symbol">:replica-version</span> <span class="integer">4</span>
  <span class="symbol">:epoch</span> <span class="integer">3</span>})
---</code></pre>
</div>
</div>
<div class="paragraph">
<p>Call <code>(onyx.api/build-resume-point your-job-map snapshot-coordinates)</code> to expand out a
resume point that defaults to the given snapshot coordinates for all windows
and input tasks.</p>
</div>
<div class="paragraph">
<p>The latest job snapshot coordinates can be read using the api call
<code>(onyx.api/job-snapshot-coordinates peer-config tenancy-id job-id)</code>.</p>
</div>
<div class="paragraph">
<p>Therefore to recover directly from a given job-id, one can call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">-&gt;&gt;</span> job-id
     (onyx.api/job-snapshot-coordinates peer-config tenancy-id)
     (onyx.api/build-resume-point new-job)
     (<span class="keyword">assoc</span> new-job <span class="symbol">:resume-point</span>)
     (onyx.api/submit-job peer-config))
---
<span class="keyword">==</span> Testing Onyx Jobs

In this chapter, we'll cover what you need to know about testing your
Onyx application code.

<span class="keyword">==</span><span class="keyword">=</span> Overview

Onyx eschews customized abstractions <span class="keyword">for</span> describing distributed
programs. As a consequence, application code written on top of Onyx ends
up being regular Clojure functions <span class="keyword">and</span> data structures. Onyx remains out
of the way, <span class="keyword">and</span> you're free to <span class="keyword">test</span> your functions as you would any
other Clojure program. It's also useful to roll up your entire job <span class="keyword">and</span>
<span class="keyword">test</span> it as it will run in production. This section is dedicated to
giving you a <span class="keyword">set</span> of idioms <span class="keyword">and</span> tools <span class="keyword">for</span> working with Onyx jobs during
the development phase.

<span class="keyword">==</span><span class="keyword">==</span> Automatic Resource Clean up

While it's easy enough to run Onyx with an in-memory ZooKeeper instance
(see the Environment chapter <span class="keyword">for</span> how to <span class="keyword">do</span> this), there are a host of
development comforts that are missing <span class="keyword">when</span> working on your Onyx code.
One <span class="keyword">key</span> pain point is the clean shutdown of resources on job completion
<span class="keyword">or</span> failure. Often <span class="keyword">when</span> developing a <span class="keyword">new</span> Onyx job, you'll make lots of
mistakes <span class="keyword">and</span> your job will be killed. Before the <span class="keyword">next</span> <span class="keyword">time</span> you run your
job, it's a good idea to make sure your peers, peer group, <span class="keyword">and</span>
development environment all cleanly shut down. This can be a moderately
tricky task at the repl where a Thread may be interrupted by a Control-C
sequence. To this end, Onyx provides a `onyx.test-helper` <span class="keyword">namespace</span> with
a handy macro known as `with-test-env`<span class="keyword">.</span>

`with-test-env` takes three parameters<span class="error">:</span> a <span class="keyword">symbol</span> to bind the development
environment <span class="keyword">var</span> to, a <span class="keyword">sequence</span> of `[number-of-peers-to-start, peer-config, env-config]`,
<span class="keyword">and</span> a body of expressions. This macro starts a development environment with the
requested number of peers, runs the body of expressions, <span class="keyword">and</span> cleanly shuts the
development enivronment down <span class="keyword">when</span> either the body of expressions completes, <span class="keyword">or</span>
an exception is thrown (included ThreadInterruptedException)<span class="keyword">.</span> You'll notice that
this is an anaphoric macro. The macro creates a development environment, then binds
it to the user supplied symbol. Using this macro, you don't need to worry about
ports remaining open that should have been closed on shutdown. You can safely
interrupt Onyx at any point in <span class="keyword">time</span> during the job execution.

In practice, this looks something like the following<span class="error">:</span>

[source,clojure]</code></pre>
</div>
</div>
<div class="paragraph">
<p>(deftest my-onyx-job-test
  (let [id (java.util.UUID/randomUUID)
        config (load-config)
        env-config (assoc (:env-config config) :onyx/tenancy-id id)
        peer-config (assoc (:peer-config config) :onyx/tenancy-id id)]
    (with-test-env [test-env [3 env-config peer-config]]
      (let [catalog &#8230;&#8203;
            workflow &#8230;&#8203;
            lifecycles &#8230;&#8203;]
            (onyx.api/submit-job peer-config
                                   {:catalog catalog
                                    :workflow workflow
                                    :lifecycles lifecycles
                                    :task-scheduler :onyx.task-scheduler/balanced})
        (let [results (take-segments! &#8230;&#8203;)
              expected &#8230;&#8203;]
          (is (= expected results)))))))</p>
</div>
<div class="listingblock">
<div class="content">
<pre>==== Code Reloading

Another painful part of writing asynchronous code in general is the
matter of reloading code without restarting your repl. Something that
plays particularly well with Onyx is clojure.tools.namespace. A pattern
that we like to use is to create a `user.clj` file for the developer
with the following contents:

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(ns user
  (:require [clojure.tools.namespace.repl :refer [refresh set-refresh-dirs]]))</p>
</div>
<div class="paragraph">
<p>(set-refresh-dirs "src" "test")</p>
</div>
<div class="paragraph">
<p>(defn init [])</p>
</div>
<div class="paragraph">
<p>(defn start [])</p>
</div>
<div class="paragraph">
<p>(defn stop [])</p>
</div>
<div class="paragraph">
<p>(defn go []
  (init)
  (start))</p>
</div>
<div class="paragraph">
<p>(defn reset []
  (stop)
  (refresh))</p>
</div>
<div class="listingblock">
<div class="content">
<pre>When you want to reload your code, invoke the `(reset)` function. You
can supply any extra application specific code in `init`, `start`, and
`stop`. Combining this pattern with the `with-test-env` macro, you
should virtually never need to restart your repl while developing Onyx
code.

==== In-Memory I/O

Production level Onyx jobs talk to input streams like Kafka, or
databases like Postgres. It's not always helpful to run those pieces of
infrastructure while developing your job. Early on, we like to just
focus on what the shape of the data will look like and you in-memory I/O
with core.async instead of Kafka or what have you. There's plenty of
documentation on how to actually use the core.async plugin. The big
question is - how does one most effectively use core.async for
development, and more realistic I/O targets for staging and production?

Our approach leverages Onyx's all-data job specification. We've found it
helpful to isolate the parts of the catalog and lifecycles that will
vary between different environments and use a "builder" pattern. We
start with a "base job" - the pieces of the job that are invariants
across all environments:

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(defn base-job [mode onyx-id task-scheduler]
  (let [datomic-uri (my-env-helper/get-datomic-uri mode onyx-id)]
    {:workflow wf/parse-event-workflow
     :catalog (cat/build-parse-event-catalog datomic-uri)
     :flow-conditions (fcp/parser-flow-conditions :parse-log
                                                  [:write-parse-failures]
                                                  [:write-to-datomic])
     :lifecycles sl/base-parse-event-lifecycles
     :task-scheduler task-scheduler}))</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The function which builds the base job takes a "mode", indicating what
environment we should construct. We like to use keywords - things like
`:dev`, `:staging`, `:prod`. Functions that receive these keywords are
often multimethods which dispatch on mode, building the appropriate
configuration files. In this example, we use the mode parameter to vary
which Datomic URI we're going to use in our catalog.

Next, we add in environment-specific code using a little utility
function to update the base job that's passed in as a parameter:

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(defn add-metrics [job m-config]
  (my-fun-utilities/add-to-job job {:lifecycles
                                     (metrics/build-metrics-lifecycles
                                       (:riemann/host m-config)
                                       (:riemann/port m-config))}))</p>
</div>
<div class="paragraph">
<p>(defn add-logging [job]
  (my-fun-utilities/add-to-job job {:lifecycles sl/log-parse-event-lifecycles}))</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Finally, we put them all together with a simple `cond-&gt;`:

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(let [mode :dev
      log? true
      metrics? false]
  (cond&#8594; (base-job mode onyx-id task-scheduler)
    log? (add-logging)
    metrics? (add-metrics m-config)))</p>
</div>
<div class="listingblock">
<div class="content">
<pre>It's important to remember that we're working with plain Clojure data
here. The sky is the limit on how you can put the building blocks
together!
[[backpressure]]

== Backpressure

A common problem with streaming platforms is whether peers and tasks can exhibit
backpressure to upstream tasks.

When Onyx's internal messaging buffers overflow, the oldest segments in the
buffer are discarded i.e. a sliding buffer. While this ensures that the
freshest segments are likely to make it through the entire workflow, and be
fully acked, input segments are still likely to be retried.

One important form of backpressure, is the
http://www.onyxplatform.org/docs/cheat-sheet/latest/#catalog-entry/:onyx/max-pending[`:onyx/max-pending`]
(&lt;&lt;information-model,Information Model&gt;&gt;), task parameter, which may be
configured on input tasks. Input tasks will only produce new segments if there
are fewer than max-pending pending (i.e. not fully acked) input segments.

One problem with max-pending as a form of backpressure, is that it doesn't take
into account the number of segments produced by the intermediate tasks, nor
whether these segments are filling up the inbound buffers of the later tasks
(due to slow processing, large numbers of produced segments, etc).

Onyx uses a simple scheme to allow backpressure to push back to upstream input
tasks. When a virtual peer fills up past a *high water mark*, the peer writes a
log message to say that its internal buffers are filling up (backpressure-on).
If any peer currently allocated to a job has set backpressure-on, then all
peers allocated to input tasks will stop reading from the input sources.

When a peers messaging buffer is reduced to below a *low water mark*, it writes
a backpressure-off log message. If no peers allocated to a job are currently
set to backpressure, then peers allocated to input tasks will resume reading
from their input sources.

Refer to &lt;&lt;peer-configuration,Peer Config&gt;&gt; for information regarding the
default backpressure settings, and how to override them.
[[deployment]]

== Deployment

Onyx has no built-in mechanism for deployment. Rather, we let you deploy at your comfort. We'll describe some approaches to doing this.

=== Deployment Style

Unlike Hadoop and Storm, Onyx does not have a built-in deployment feature. To deploy your application, you need to uberjar your program and place it on every node in your cluster. Start up the uberjar, passing it your shared Onyx ID and ZooKeeper address. Once it connects, you've successfully deployed!

We've chosen not to build in a deployment strategy because there are so many flexible approaches to handling deployment. S3, Docker, Mesos, Swarm, and Kubernetes are a few good choices. We'll describe some of these strategies below.

==== Shared File System

Perhaps the most primitive deployment that you can use is a shared file system. Write a small script to SCP your uberjar to each of the nodes in your cluster and start the jar. You might use S3 for this, and a utility that allows you to manipulate a few SSH sessions in parallel. This is great for getting started on 3 nodes or so. You'll want to use something a bit more elaborate as you go to production and get bigger, though.

==== Docker

We recommend packaging your uberjar into a Docker container. This is useful for locking in a specific Java version. Make sure you expose the ports that peers will be communicating on (this is configurable, see the peer configuration chapter). Once you have that down, you can upload your Docker image to DockerHub and use a simple script to pull down your Docker image and begin its execution. This is another step in the right direction, but read on to remove the scripting part of this task for real production systems.

==== Mesos and Marathon

Mesos and Marathon are a pair of applications that work together to manage your entire cluster of machines. I recommend deploying your Docker image onto Marathon, which will allow you to scale at runtime and avoid any scripting. Marathon ensures that if your Docker container goes down, it will be restarted. This is one of our favorite solutions for production scale, cluster-wide management at the moment.

==== Kubernetes

We are less familiar with Kubernetes as it's a bit younger than Mesos and Marathon, but Kubernetes will deliver roughly the same functionality that Mesos and Marathon will.
[[production-check-list]]
== Production Check List

A production check list is included in the &lt;&lt;environment,Environment
documentation&gt;&gt;.
[[monitoring]]
== Monitoring

When setting up an Onyx cluster in production, it's helpful to know what
Onyx itself is doing. Onyx exposes a set of callbacks that are triggered
on certain actions.

=== Monitoring Hooks

When you're taking Onyx to production, it's not enough to know what your
application-specific code is doing. You need to have insight into how
Onyx is operating internally to be able to tune performance at an
optimal level. Onyx allows you to register callbacks that are invoked
when critical sections of code are executed in Onyx, returning a map
that includes latency and data load size if appropriate.

=== Callback Specification

Callback functions that are given to Onyx for monitoring take exactly
two parameters. The first parameter is the monitoring configuration, the
second is a map. The return value of the function is ignored. The event
names and keys in their corresponding maps are listed in a later section
of this chapter, as well as a discussion about monitoring configuration.
Here's an example of a callback function:

[source,clojure]
------

(defn do-something [config {:keys [event latency bytes]}]
 ;; Write some metrics to Riemann or another type of services.
 (send-to-riemann event latency bytes))
------

=== Registering Callbacks

To register callbacks, create a map of event name key to callback
function. This map must have a key `:monitoring`, mapped to keyword
`:custom`. If you want to ignore all callbacks, you can instead supply
`:no-op`. Monitoring is optional, so you can skip any monitoring code
entirely if you don't want to use this feature.

A registration example might look like:

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(defn std-out [config event-map]
  ;; <code>config</code> is the <code>monitoring-config</code> var.
  (prn event-map))</p>
</div>
<div class="paragraph">
<p>(def monitoring-config
  {:monitoring :custom
   :zookeeper-write-log-entry std-out
   :zookeeper-read-log-entry std-out
   :zookeeper-write-catalog std-out
   :zookeeper-write-workflow std-out
   :zookeeper-write-flow-conditions std-out
   :zookeeper-force-write-chunk std-out
   :zookeeper-read-catalog std-out
   :zookeeper-read-lifecycles std-out
   :zookeeper-gc-log-entry std-out})</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<p>Pass the monitoring config as a second parameter to the <code>start-peer-group</code> function.
(def peer-group (onyx.api/start-peer-group (assoc peer-config :monitoring-config monitoring-config)))</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre>=== Monitoring Events

This is the list of all monitoring events that you can register hooks
for. The keys listed are present in the map that is passed to the
callback function. The names of the events should readily identify what
has taken place to trigger the callback.

[cols="2", options="header"]
|===
| Event Name | Keys

|`:zookeeper-write-log-entry` |`:event`, `:latency`, `:bytes`
|`:zookeeper-read-log-entry` |`:event`, `:latency`, `:bytes`
|`:zookeeper-write-catalog` |`:event`, `:latency`, `:bytes`
|`:zookeeper-write-workflow` |`:event`, `:latency`, `:bytes`
|`:zookeeper-write-flow-conditions` |`:event`, `:latency`, `:bytes`
|`:zookeeper-write-lifecycles` |`:event`, `:latency`, `:bytes`
|`:zookeeper-write-windows` |`:event`, `:latency`, `:bytes`
|`:zookeeper-write-triggers` |`:event`, `:latency`, `:bytes`
|`:zookeeper-write-job-metadata` |`:event`, `:latency`, `:bytes`
|`:zookeeper-write-task` |`:event`, `:latency`, `:bytes`
|`:zookeeper-write-job-hash` |`:event`, `:latency`, `:bytes`
|`:zookeeper-write-chunk` |`:event`, `:latency`, `:bytes`
|`:zookeeper-write-job-scheduler` |`:event`, `:latency`, `:bytes`
|`:zookeeper-write-messaging` |`:event`, `:latency`, `:bytes`
|`:zookeeper-write-exception` |`:event`, `:latency`, `:bytes`
|`:zookeeper-force-write-chunk` |`:event`, `:latency`, `:bytes`
|`:zookeeper-write-origin` |`:event`, `:latency`, `:bytes`
|`:zookeeper-read-catalog` |`:event`, `:latency`
|`:zookeeper-read-workflow` |`:event`, `:latency`
|`:zookeeper-read-flow-conditions` |`:event`, `:latency`
|`:zookeeper-read-lifecycles` |`:event`, `:latency`
|`:zookeeper-read-windows` |`:event`, `:latency`
|`:zookeeper-read-triggers` |`:event`, `:latency`
|`:zookeeper-read-job-metadata` |`:event`, `:latency`
|`:zookeeper-read-task` |`:event`, `:latency`
|`:zookeeper-read-job-hash` |`:event`, `:latency`
|`:zookeeper-read-chunk` |`:event`, `:latency`
|`:zookeeper-read-origin` |`:event`, `:latency`
|`:zookeeper-read-job-scheduler` |`:event`, `:latency`
|`:zookeeper-read-messaging` |`:event`, `:latency`
|`:zookeeper-read-exception` |`:event`, `:latency`
|`:zookeeper-gc-log-entry` |`:event`, `:latency`, `:position`
|`:peer-retry-segment` |`:event`, `:latency`
|`:peer-complete-message` |`:event`, `:latency`
|`:peer-gc-peer-link` |`:event`
|`:peer-backpressure-on` |`:event`, `:id`
|`:peer-backpressure-off` |`:event`, `:id`
|`:group-prepare-join` |`:event`, `:id`
|`:group-notify-join` |`:event`, `:id`
|`:group-accept-join` |`:event`, `:id`
|`:peer-send-bytes` |`:event`, `:id`, `:bytes`
|===
[[performance-tuning]]
== Performance Tuning

This chapter details a few tips for getting your Onyx cluster to run as
fast as possible.

=== Onyx

* Use Clojure 1.7+. 1.7 and 1.8 have some considerable performance enhancements compared to 1.6.
* **SETUP METRICS**. We cannot stress this point enough. Please read the guide at https://github.com/onyx-platform/onyx-metrics[onyx-metrics] to get started.
* Set the timbre log level to elide logging calls in production. This should be done at compile time,
 i.e. when AOT compiling, or when running via leinigen. You can do using the
 environment variable: `TIMBRE_LOG_LEVEL=info command_to_start_your_peers_or_compile_AOT`.
* Turn off clojure assertions. Onyx uses assertions liberally, to find errors early, however these do have an associated cost.
  Use `:global-vars {*assert* false}` in your leiningen profile, or `(set! assert false)` in your system bootup namespace.
* Use `JVM_OPTS="-server"` in production.
* Use `JVM_OPTS="-XX:+UseG1GC"`. The G1GC has more predictable performance that can improve latency, though may decrease throughput by a small amount. It is **strongly** recommended you use this GC, unless you have a reason not to.
* Check that you do not use reflection in any of the code running in your onyx
 tasks critical paths e.g. in onyx/fn, before/after-batch lifecycles,
 aggregations, etc. You can check for reflection by using `:global-vars {*warn-on-reflection* false}` in your lein profile.
* Tweak the `:onyx/batch-size` for the job's tasks. A batch size of 20-100 segments is a reasonable start that will amortise the cost of onyx's task lifecycle vs latency.
* For small segments, batch multiple segments into a single segment, and
 treat each new segment as a rolled up batch.
* Tweak the batch timeout in each catalog entry to trade off increased
 latency for higher throughput. Counterintuitively, note that increased batch sizes
 can actually decrease average case latency, as improved throughput can decrease queuing effects.
 * The peer-config option http://www.onyxplatform.org/docs/cheat-sheet/latest/#peer-config/:onyx.messaging/allow-short-circuit-QMARK[`:onyx.messaging/allow-short-circuit?`]
(&lt;&lt;peer-configuration,Peer Config&gt;&gt;), should be set to true in production.
* Profile your code locally using http://www.oracle.com/technetwork/java/javaseproducts/mission-control/java-mission-control-1998576.html[Java Flight Recorder / Mission Control].
 The easiest way to get started is to create a benchmark test, and the following JVM_OPTS `-XX:+UnlockCommercialFeatures -XX:+FlightRecorder" -XX:+UnlockDiagnosticVMOptions -XX:StartFlightRecording=duration=1080s,filename=localrecording.jfr`.
 This will save a file to "localrecording.jfr, which you can open in mission control (which can be started via the command `jmc`. You will need Oracle's JVM to use this functionality.
* Start roughly 1 virtual peer per core per machine. When using Aeron
messaging, `cores = virtual peers + subscribers` is a good guideline.
This recommendation is a good starting point, however may not hold
true when some virtual peers are largely idle, or spend much of their
time I/O blocked.
* Use a custom compression scheme, rather than Nippy. You can configure
custom compression/decompression functions via the peer configuration.
* Increase the number of acker peers through the peer configuration as
your cluster gets larger
* Tune the number of Aeron subscriber threads, if serialization is a
large proportion of work performed in tasks.

=== ZooKeeper

* Put the ZooKeeper journal on its own physical volume

Zookeeper tends to not get a huge amount of traffic, so this probably
won't offer a huge performance boost. It's helpful if you're trying to
make your processing latency as predictable as possible, though.

=== Messaging

==== Aeron

Ensure you disable the embedded media driver, and instead use an
independent media driver (see &lt;&lt;messaging,Media Driver&gt;&gt;)

When testing performance with a single node using the Aeron messaging
layer, connection short circuiting may cause very misleading results.

The peer-config option
http://www.onyxplatform.org/docs/cheat-sheet/latest/#peer-config/:onyx.messaging/allow-short-circuit-QMARK[`:onyx.messaging/allow-short-circuit?`]
(&lt;&lt;peer-configuration,Peer Config&gt;&gt;), should be be set to false for realistic
performance testing when only a single node is available for testing. Ensure
this option is set to true when operating in production.

Please refer to the &lt;&lt;messaging, Aeron messaging section&gt;&gt; for general discussion of
the Aeron messaging implementation and its characterstics.
[[environment]]

== Environment

In this chapter, we'll discuss what you need to set up a develop and
production environment.

=== Development Environment

==== Dependencies

* Java 8+
* Clojure 1.7+

==== Explanation

One of the primary design goals of Onyx is to make the development
environment as close as possible to production - without making the
developer run a lot of services locally. A development environment in
Onyx merely needs Clojure 1.7+ to operate. A ZooKeeper server is spun up
in memory via Curator, so you don't need to install ZooKeeper locally if
you don't want to.

=== Production Environment

==== Dependencies

* Java 8+
* Clojure 1.7+
* ZooKeeper 3.4.5+

==== Multi-node &amp; Production Checklist

Congratulations! You're going to production, or at least testing your
Onyx jobs with a multi-node setup.

We strongly recommend you run through this checklist before you do so,
as it will likely save you a lot of time.

* [ ] *Ensure your JVM is running with JVM opts -server* Performance
will be greatly decreased if you do not run Onyx via Java without at
least `-server` JVM opts.
* [ ] **Disable embedded ZooKeeper**: when `onyx.api/start-env` is
called with a config where `:zookeeper/server? true`, it will start an
embedded ZooKeeper. `:zookeeper/server?` should be set to `false` in
production.
* [ ] **Setup production ZooKeeper**: A full
https://zookeeper.apache.org/[ZooKeeper ensemble] should be used in lieu
of the testing ZooKeeper embedded in Onyx.
* [ ] *Increase maximum ZK connections* Onyx establishes a large number
of ZooKeeper connections, in which case you will see an exception like
the following:
`WARN org.apache.zookeeper.server.NIOServerCnxn: Too many connections from /127.0.0.1 - max is 10`.
Increase the number of connections in zoo.cfg, via `maxClientCnxns`.
This should be set to a number moderately larger than the number of
virtual peers that you will start.
* [ ] **Configure ZooKeeper address to point an ensemble**:
`:zookeeper/address` should be set in your peer-config e.g.
`:zookeeper/address "server1:2181,server2:2181,server3:2181"`.
* [ ] **Ensure all nodes are using the same `:onyx/tenancy-id`**:
`:onyx/tenancy-id` in the peer-config is used to denote which cluster a
virtual peer should join. If all your nodes do not use the same
`:onyx/tenancy-id`, they will not be a part of the same cluster and will
not run the same jobs. Any jobs submitted a cluster must also use the
same `:onyx/tenancy-id` to ensure that cluster runs the job.
* [ ] **Do not use core async tasks**: switch all input or output tasks
from core.async as it is a not a suitable medium for multi-node use and
will result in many issues when used in this way. The
https://github.com/onyx-platform/onyx-kafka[Kafka plugin] is one
recommended alternative.
* [ ] **Test on a single node with without short circuiting**: when
`:onyx.messaging/allow-short-circuit?` is `true`, Aeron messaging will
be short circuited completely. To test messaging on a local mode as if
it's in production, set `:onyx.messaging/allow-short-circuit? false`.
* [ ] **Ensure short circuiting is enabled in production**: short
circuiting improves performance by locally messaging where possible.
Ensure `:onyx.messaging/allow-short-circuit? true` is set in the
peer-config on production.
* [ ] **Set messaging bind address**: the messaging layer must be bound
to the network interface used by peers to communicate. To do so, set
`:onyx.messaging/bind-addr` in peer-config to a string defining the
interface's IP. On AWS, this IP can easily be obtained via
`(slurp "http://169.254.169.254/latest/meta-data/local-ipv4")`.
* [ ] **Is your bind address external facing?**: If your bind address is
something other than the one accessible to your other peers (e.g.
docker, without net=host), then you will need to define an external
address to advertise. This can be set via
`:onyx.messaging/external-addr` in peer-config.
* [ ] **Open UDP ports for Aeron**: Aeron requires the port defined in
`:onyx.messaging/peer-port` to be open for UDP traffic.
* [ ] **Setup an external Aeron Media Driver**: If messaging performance
is a factor, it is recommended that the Aeron Media Driver is run out of
process. First, disable the embedded driver by setting
`:onyx.messaging.aeron/embedded-driver? false`. An example out of
process media driver is included in
https://github.com/onyx-platform/lib-onyx/blob/master/src/lib_onyx/media_driver.clj[lib-onyx].
This media driver can be started via `lein run -m`, or via an uberjar,
each by referencing the correct namespace, which contains a main entry
point. Ensure that the media driver is started with JVM opts `-server`.
* [ ] **Setup metrics**: when in production, it is essential that you
are able to measure retried messages, input message complete latency,
throughput and batch latency. Setup Onyx to use
https://github.com/onyx-platform/onyx-metrics[onyx-metrics]. We
recommend at very least using the timbre logging plugin, which is easy
to setup.

==== ZooKeeper

===== Environment Launch of In-Memory ZooKeeper

To launch an in-memory ZooKeeper instance, add `:zookeeper/server? true`
to the environment options. Also, specify
`:zookeeper.server/port &lt;my port&gt;` so that Curator knows what port to
start running the server on.

If your deployment throws an exception and doesn't shut down ZooKeeper,
it will remain open. Firing up the environment again will cause a port
collision, so be sure to restart your repl in that case.

===== Peer Connection to In-Memory ZooKeeper

Add `:zookeeper/address "127.0.0.1:&lt;my port&gt;"` to the peer options as
usual. In-memory Zookeeper is completely opaque to the peer.

==== Example

Here's an example of using ZooKeeper in-memory, with some non-ZooKeeper
required parameters elided.

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def env-config
  {:zookeeper/address "127.0.0.1:2182"
   :zookeeper/server? true
   :zookeeper.server/port 2182
   :onyx/tenancy-id id})</p>
</div>
<div class="paragraph">
<p>(def peer-opts
  {:zookeeper/address "127.0.0.1:2182"
   :onyx/tenancy-id id})</p>
</div>
<div class="listingblock">
<div class="content">
<pre>=== Networking / Firewall

Messaging requires the _UDP_ port to be open for port set
`:onyx.messaging/peer-port`.

All peers require the ability to connect to the ZooKeeper instances over
TCP.

==== Explanation

Running a ZooKeeper cluster is a requirement for a lot of fault tolerant
systems. See
http://zookeeper.apache.org/doc/r3.1.2/zookeeperStarted.html[this link]
for getting set up. I won't go into detail since this is a particularly
common set up. We recommend using
https://github.com/Netflix/exhibitor[Exhibitor] to manage clustered
ZooKeeper.

==== Example

Notice that all we're doing is extending the address string to include
more host:port pairs. This uses the standard ZooKeeper connection
string, so you can use authentication here too if you need it.

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def peer-opts
  {&#8230;&#8203;
   :zookeeper/address "10.132.8.150:2181,10.132.8.151:2181,10.132.8.152:2181"
   &#8230;&#8203;})</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[[peer-configuration]]
== Peer Configuration

The chapter describes the all options available to configure the virtual peers and development environment.

=== Base Configuration

|===
| key name | type
|`:onyx/tenancy-id`
|`any`

|`:zookeeper/address`
|`string`
|===

=== Environment Only

|===
| key name | type | optional?

|`:zookeeper/server?`
|`boolean`
|Yes

|`:zookeeper.server/port`
|`int`
|Yes

|`:onyx.bookkeeper/server?`
|`boolean`
|Yes

|`:onyx.bookkeeper/local-quorum?`
|`boolean`
|Yes

|`:onyx.bookkeeper/local-quorum-ports`
|`[int]`
|Yes

|`:onyx.bookkeeper/port`
|`int`
|Yes

|`:onyx.bookkeeper/base-journal-dir`
|`string`
|Yes

|`:onyx.bookkeeper/base-ledger-dir`
|`string`
|Yes
|===

=== Peer Only

==== Base Configuration

|===
| key name | type | default

|`:onyx.peer/inbox-capacity`
|`int`
|`1000`

|`:onyx.peer/outbox-capacity`
|`int`
|`1000`

|`:onyx.peer/retry-start-interval`
|`int`
|`2000`

|`:onyx.peer/join-failure-back-off`
|`int`
|`250`

|`:onyx.peer/drained-back-off`
|`int`
|`400`

|`:onyx.peer/peer-not-ready-back-off`
|`int`
|`2000`

|`:onyx.peer/job-not-ready-back-off`
|`int`
|`500`

|`:onyx.peer/fn-params`
|`map`
|`{}`

|`:onyx.peer/tags`
|`vector`
|`[]`

|`:onyx.peer/backpressure-check-interval`
|`int`
|`10`

|`:onyx.peer/backpressure-low-water-pct`
|`int`
|`30`

|`:onyx.peer/backpressure-high-water-pct`
|`int`
|`60`

|`:onyx.zookeeper/backoff-base-sleep-time-ms`
|`int`
|`1000`

|`:onyx.zookeeper/backoff-max-sleep-time-ms`
|`int`
|`30000`

|`:onyx.zookeeper/backoff-max-retries`
|`int`
|`5`

|`:onyx.messaging/inbound-buffer-size`
|`int`
|`20000`

|`:onyx.messaging/completion-buffer-size`
|`int`
|`1000`

|`:onyx.messaging/release-ch-buffer-size`
|`int`
|`10000`

|`:onyx.messaging/retry-ch-buffer-size`
|`int`
|`10000`

|`:onyx.messaging/peer-link-gc-interval`
|`int`
|`90000`

|`:onyx.messaging/peer-link-idle-timeout`
|`int`
|`60000`

|`:onyx.messaging/ack-daemon-timeout`
|`int`
|`60000`

|`:onyx.messaging/ack-daemon-clear-interval`
|`int`
|`15000`

|`:onyx.messaging/decompress-fn`
|`function`
|`onyx.compression.nippy/decompress`

|`:onyx.messaging/compress-fn`
|`function`
|`onyx.compression.nippy/compress`

|`:onyx.messaging/impl`
|`keyword`
|`:aeron`

|`:onyx.messaging/bind-addr`
|`string`
|`nil`

|`:onyx.messaging/peer-port`
|`int`
|`nil`

|`:onyx.messaging/allow-short-circuit?`
|`boolean`
|`true`

|`:onyx.messaging.aeron/embedded-driver?`
|`boolean`
|`true`

|`:onyx.messaging.aeron/subscriber-count`
|`int`
|`2`

|`:onyx.messaging.aeron/write-buffer-size`
|`int`
|`1000`

|`:onyx.messaging.aeron/poll-idle-strategy`
|`keyword`
|`:high-restart-latency`

|`:onyx.messaging.aeron/offer-idle-strategy`
|`keyword`
|`:high-restart-latency`

|===

===== `:onyx.peer/inbox-capacity`

Maximum number of messages to try to prefetch and store in the inbox, since reading from the log happens asynchronously.

===== `:onyx.peer/outbox-capacity`

Maximum number of messages to buffer in the outbox for writing, since writing to the log happens asynchronously.

===== `:onyx.peer/retry-start-interval`

Number of ms to wait before trying to reboot a virtual peer after failure.

===== `:onyx.peer/drained-back-off`

Number of ms to wait before trying to complete the job if all input tasks have been exhausted. Completing the job may not succeed if the cluster configuration is being shifted around.

===== `:onyx:onyx.peer/peer-not-ready-back-off`

Number of ms to back off and wait before retrying the call to `start-task?` lifecycle hook if it returns false.

===== `:onyx:onyx.peer/job-not-ready-back-off`

Number of ms to back off and wait before trying to discover configuration needed to start the subscription after discovery failure.

===== `:onyx.peer/join-failure-back-off`

Number of ms to wait before trying to rejoin the cluster after a previous join attempt has aborted.

===== `:onyx.peer/fn-params`

A map of keywords to vectors. Keywords represent task names, vectors represent the first parameters to apply
to the function represented by the task. For example, `{:add [42]}` for task `:add` will call the function
underlying `:add` with `(f 42 &lt;segment&gt;)`.

===== `:onyx.peer/tags`

Tags which denote the capabilities of this peer in terms of user-defined functionality. Must be specified as a vector of keywords. This is used in combination with `:onyx/required-tags` in the catalog to force tasks to run on certain sets of machines.

===== `:onyx.zookeeper/backoff-base-sleep-time-ms`

Initial amount of time to wait between ZooKeeper connection retries

===== `:onyx.zookeeper/backoff-max-sleep-time-ms`

Maximum amount of time in ms to sleep on each retry

===== `:onyx.zookeeper/backoff-max-retries`

Maximum number of times to retry connecting to ZooKeeper

===== `:onyx.peer/backpressure-low-water-pct`

Percentage of messaging inbound-buffer-size that constitutes a low water mark for backpressure purposes.

===== `:onyx.peer/backpressure-high-water-pct`

Percentage of messaging inbound-buffer-size that constitutes a high water mark for backpressure purposes.

===== `:onyx.peer/backpressure-check-interval`

Number of ms between checking whether the virtual peer should notify the cluster of backpressure-on/backpressure-off.

===== `:onyx.messaging/inbound-buffer-size`

Number of messages to buffer in the core.async channel for received segments.

===== `:onyx.messaging/completion-buffer-size`

Number of messages to buffer in the core.async channel for completing messages on an input task.

===== `:onyx.messaging/release-ch-buffer-size`

Number of messages to buffer in the core.async channel for released completed messages.

===== `:onyx.messaging/retry-ch-buffer-size`

Number of messages to buffer in the core.async channel for retrying timed-out messages.

===== `:onyx.messaging/peer-link-gc-interval`

The interval in milliseconds to wait between closing idle peer links.

===== `:onyx.messaging/peer-link-idle-timeout`

The maximum amount of time that a peer link can be idle (not looked up in the state atom for usage) before it is eligible to be closed. The connection will be reopened from scratch the next time it is needed.

===== `:onyx.messaging/ack-daemon-timeout`

Number of milliseconds that an ack value can go without being updates on a daemon before it is eligible to time out.

===== `:onyx.messaging/ack-daemon-clear-interval`

Number of milliseconds to wait for process to periodically clear out ack-vals that have timed out in the daemon.

===== `:onyx.messaging/decompress-fn`

The Clojure function to use for messaging decompression. Receives one argument - a byte array. Must return the decompressed value of the byte array.

===== `:onyx.messaging/compress-fn`

The Clojure function to use for messaging compression. Receives one argument - a sequence of segments. Must return a byte array representing the segment seq.

===== `:onyx.messaging/impl`

The messaging protocol to use for peer-to-peer communication.

===== `:onyx.messaging/bind-addr`

An IP address to bind the peer to for messaging. Defaults to `nil`, binds to it's external IP to the result of calling `http://checkip.amazonaws.com`.

===== `:onyx.messaging/peer-port`

The port that peers should use to communicate.

===== `:onyx.messaging/allow-short-circuit?`

A boolean denoting whether to allow virtual peers to short circuit networked messaging when colocated with the other virtual peer. Short circuiting allows for direct transfer of messages to a virtual peer's internal buffers, which improves performance where possible. This configuration option is primarily for use in perfomance testing, as peers will not generally be able to short circuit messaging after scaling to many nodes.

===== `:onyx.messaging.aeron/embedded-driver?`

A boolean denoting whether an Aeron media driver should be started up with the environment. See https://github.com/onyx-platform/onyx/blob/0.8.8/src/onyx/messaging/aeron_media_driver.clj[Aeron Media Driver] for an example for how to start the media driver externally.

===== `:onyx.messaging.aeron/subscriber-count`

The number of Aeron subscriber threads that receive messages for the peer-group.  As peer-groups are generally configured per-node (machine), this setting can bottleneck receive performance if many virtual peers are used per-node, or are receiving and/or de-serializing large volumes of data. A good guidline is is `num cores = num virtual peers + num subscribers`, assuming virtual peers are generally being fully utilised.

===== `:onyx.messaging.aeron/write-buffer-size`

Size of the write queue for the Aeron publication. Writes to this queue will currently block once full.

===== `:onyx.messaging.aeron/poll-idle-strategy`

The Aeron idle strategy to use between when polling for new messages. Currently, two choices `:high-restart-latency` and `:low-restart-latency` can be chosen. low-restart-latency may result in lower latency message, at the cost of higher CPU usage or potentially reduced throughput.

===== `:onyx.messaging.aeron/offer-idle-strategy`

The Aeron idle strategy to use between when offering messages to another peer. Currently, two choices `:high-restart-latency` and `:low-restart-latency` can be chosen. low-restart-latency may result in lower latency message, at the cost of higher CPU usage or potentially reduced throughput.

=== Peer Full Example

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def peer-opts
  {:onyx/tenancy-id "df146eb8-fd6e-4903-847e-9e748ca08021"
   :zookeeper/address "127.0.0.1:2181"
   :onyx.peer/inbox-capacity 2000
   :onyx.peer/outbox-capacity 2000
   :onyx.peer/retry-start-interval 4000
   :onyx.peer/join-failure-back-off 500
   :onyx.peer/drained-back-off 400
   :onyx.peer/peer-not-ready-back-off 5000
   :onyx.peer/job-not-ready-back-off 1000
   :onyx.peer/fn-params {:add [42]}
   :onyx.peer/zookeeper-timeout 10000
   :onyx.messaging/completion-buffer-size 2000
   :onyx.messaging/release-ch-buffer-size 50000
   :onyx.messaging/retry-ch-buffer-size 100000
   :onyx.messaging/ack-daemon-timeout 90000
   :onyx.messaging/ack-daemon-clear-interval 15000
   :onyx.messaging/decompress-fn onyx.compression.nippy/decompress
   :onyx.messaging/compress-fn onyx.compression.nippy/compress
   :onyx.messaging/impl :aeron
   :onyx.messaging/bind-addr "localhost"
   :onyx.messaging/peer-port 40200})</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[[information-model]]
== Information Model

The information model is now described in the
http://www.onyxplatform.org/docs/cheat-sheet/latest/[Cheat Sheet]. The
information model is also described in a
https://github.com/onyx-platform/onyx/blob/master/src/onyx/information_model.cljc[nested
map].
[[scheduling]]
== Scheduling

Onyx offers fine-grained control of how many peers are allocated to
particular jobs and tasks. This section outlines how to use the built-in
schedulers.

=== Allocating Peers to Jobs and Tasks

In a masterless design, there is no single entity that assigns tasks to
peers. Instead, peers need to contend for tasks to execute as jobs are
submitted to Onyx. Conversely, as peers are added to the cluster, the
peers must "shift" to distribute the workload across the cluster. Onyx
ships out-of-the-box job and task allocation policies. End users can
change the levels of fairness that each job gets with respect to cluster
power. And remember, one virtual peer executes _at most_ one task.

==== Job Schedulers

Each running Onyx instance is configured with exactly one job scheduler.
The purpose of the job scheduler is to coordinate which jobs peers are
allowed to volunteer to execute. There are a few different kinds of
schedulers, listed below. To use each, configure the Peer Options map
with key `:onyx.peer/job-scheduler` to the value specified below.

===== Greedy Job Scheduler

The Greedy job scheduler allocates _all peers_ to each job in the order
that it was submitted. For example, suppose you had 100 virtual peers
and you submitted two jobs - job A and job B. With a Greedy scheduler,
_all_ 100 peers would be allocated to job A. If job A completes, all 100
peers will then execute tasks for job B. This _probably_ isn't desirable
when you're running streaming workflows, since they theoretically never
end.

To use this scheduler, set key `:onyx.peer/job-scheduler` to
`:onyx.job-scheduler/greedy` in the Peer Options.

*Peer Addition*

In the event that a peer joins the cluster while the Greedy job
scheduler is running, that new peer will be allocated to the current job
that is being run greedily.

*Peer Removal*

In the event that a peer leaves the cluster while the Greedy job
scheduler is running, no peers will be shifted off of the job that is
greedily running.

*Job Addition*

If a job is submitted while this scheduler is running, no peers will be
allocated to this job. The only exception to this rule is if _no_ jobs
are currently running. In this case, all peers will be allocated to this
job.

*Job Removal*

If a job is completed or otherwise canceled, _all_ of the peers executed
that task will move to the job that was submitted after this job.

===== Balanced Robin Job Scheduler

The Balanced job scheduler allocates peers in a rotating fashion to jobs
that were submitted. For example, suppose that you had 100 virtual peers
(virtual peer 1, virtual peer 2, ... virtual peer 100) and you submitted
two jobs - job A and job B. With a Balanced scheduler, both jobs will
end up with 50 virtual peers allocated to each. This scheduler begins
allocating by selecting the first job submitted.

To use this scheduler, set key `:onyx.peer/job-scheduler` to
`:onyx.job-scheduler/balanced` in the Peer Options.

*Peer Addition*

In the event that a peer joins the cluster while the Balanced scheduler
is running, that new peer will be allocated to the job that most evenly
balances the cluster according to a the number of jobs divided by the
number of peers. If there is a tie, the new peer is added to the
earliest submitted job.

*Peer Removal*

In the event that a peer leaves the cluster while the Balanced scheduler
is running, the peers across _all_ jobs will be rebalanced to evenly
distribute the workflow.

*Job Addition*

If a job is submitted while this scheduler is running, the entire
cluster will be rebalanced. For example, if job A has all 100 peers
executing its task, and job B is submitted, 50 peers will move from job
A to job B.

*Job Removal*

If a job is completed or otherwise canceled while this scheduler is
running, the entire cluster will be rebalanced. For example, if job A,
B, and C had 20 peers executing each of its tasks (60 peers total), and
job C finished, job A would gain 10 peers, and job B would gain 10
peers.

===== Percentage Job Scheduler

The Percentage job scheduler allows jobs to be submitted with a
percentage value. The percentage value indicates what percentage of the
cluster will be allocated to this job. The use case for this scheduler
is for when you have a static number of jobs and a varying number of
peers. For example, if you have 2 jobs - A and B, you'd give each of
this percentage values - say 70% and 30%, respectively. If you had 100
virtual peers running, 70 would be allocated to A, and 30 to B. If you
then added 100 more peers to the cluster, job A would be allocated 140
peers, and job B 60. This dynamically scaling is a big step forward over
statically configuring slots, which is normal in ecosystems like Hadoop
and Storm.

If there aren't enough peers to satisfy the percentage values of all the
jobs, this scheduler will allocate with priority to jobs with the
highest percentage value. When percentage values are equal, the earliest
submitted job will get priority. In the event that jobs are submitted,
and the total percentage value exceeds 100%, the earliest submitted jobs
that do not exceed 100% will receive peers. Jobs that go beyond it will
not receive peers. For example, if you submitted jobs A, B, and C with
70%, 30%, and 20% respectively, jobs A and B would receive peers, and C
will not be allocated any peers until either A or B completes.

If the total percentages of all submitted jobs doesn't sum up to 100%,
the job with the highest percentage value will receive the extra peers.
When percentage values are equal, the earliest submitted job will get
priority.

If the algorithm determines that any job should receive a number of
peers that is less than the minimum number it needs to execute, that job
receives no peers.

To use this scheduler, set key `:onyx.peer/job-scheduler` to
`:onyx.job-scheduler/percentage` in the Peer Options.

*Peer Addition*

In the event that a peer joins the cluster while the Percentage job
scheduler is running, the entire cluster will rebalance.

*Peer Removal*

In the event that a peer leaves the cluster while the Percentage job
scheduler is running, the entire cluster will rebalance.

*Job Addition*

If a job is submitted while this scheduler is running, the entire
cluster will be rebalanced.

*Job Removal*

If a job is completed or otherwise canceled while this scheduler is
running, the entire cluster will be rebalanced.

==== Task Schedulers

Each Onyx job is configured with exactly one task scheduler. The task
scheduler is specified at the time of calling `submit-job`. The purpose
of the task scheduler is to control the order in which available peers
are allocated to which tasks. There are a few different Task Scheduler
implementations, listed below. To use each, call `onyx.api/submit-job`.
The second argument of this function is a map. Supply a
`:task-scheduler` key and map it to the value specified below.

===== Balanced Task Scheduler

The Balanced Scheduler takes a topological sort of the workflow for a
specific job. As peers become available, this scheduler assigns tasks to
peers in a rotating order. For example, if a workflow has a topological
sort of tasks A, B, C, and D, this scheduler assigns each peer to tasks
A, B, C, D, A, B, C, D, ... and so on.

To use, set `:task-scheduler` in `submit-job` to
`:onyx.task-scheduler/balanced`.

*Peer Removal*

If a peer fails, or is otherwise removed from the cluster, the Task
scheduler defers to the Job scheduler to rebalance the cluster. If a new
peer is added to this task as a result of a peer failing in another job,
it is assigned the next task in the balanced sequence.

*Max Peer Parameter*

With the Balanced Task Scheduler, each entry in the catalog can specify
a key of `:onyx/max-peers` with an integer value &gt; 0. When this key is
set, Onyx will never assign that task more than that number of peers.
Balanced will simply skip the task for allocation when more peers are
available, and continue assigning balanced to other tasks.

===== Percentage Task Scheduler

The Percentage Scheduler takes a set of tasks, all of which must be
assigned a percentage value (`:onyx/percentage`) in the corresponding
catalog entries. The percentage values _must_ add up to 100 or less.
Percent values may be integers between 1 and 99, inclusive. This
schedule will allocate peers for this job in proportions to the
specified tasks. As more or less peers join the cluster, allocations
will automatically scale. For example, if a job has tasks A, B, and C
with 70%, 20%, and 30% specified as their percentages, and there are 10
peers, task A receives 7 peers, B 2 peers, and C 1 peer.

This scheduler handles corner cases (fractions of peers) in the same way
as the Percentage Job Scheduler. See that documentation for a full
description.

To use, set `:task-scheduler` in `submit-job` to
`:onyx.task-scheduler/percentage`.

*Peer Removal*

If a peer fails, or is otherwise removed from the cluster, the Task
scheduler rebalances all the peers for even distribution.

===== Colocation Task Scheduler

The Colocation Schedule takes all of the tasks for a job and, if
possible, assigns them to the peers on a single physical machine
represented by the same peer group. If a job has 4 tasks and the cluster
is one machine with 5 peers, 4 peers will become active. If that machine
had 8 peers, all 8 would become active as this schedule operates in peer
chunks that are divisible by the task size. If more machines are capable
of executing the entire job, they will also be used.

This scheduler is useful for dramatically increasing performance of jobs
where the latency is bound by the network of transmitting data across
tasks. Using this scheduler with peer short circuiting will ensure that
segments are never serialized and never cross the network between tasks
(with the exception of grouping tasks). Onyx's usual fault tolerancy
mechanisms are still used to ensure that data is processed in the
presence of machine failure.

To use, set `:task-scheduler` in `submit-job` to
`:onyx.task-scheduler/colcocated`.

To use colocation, but to disable the scheduler's affinity to always
send segments to a local peer, set
`:onyx.task-scheduler.colocated/only-send-local?` to `false` in the peer
config. This is desirable when optimal performance depends on the
uniformity of tasks being evenly assigned to machines in your cluster,
but strictly local execution is not helpful for performance.

*Peer Addition*

If a peer is added to the cluster and its machine is capable of
executing all the tasks for this job, the entire machine will be used -
provided that it falls into the pool of peers elligible to execute this
job, per the job scheduler's perogative.

*Peer Removal*

If a peer is removed, all the peers associated with this job's tasks for
this chunk of peers will stop executing their tasks.

=== Tags

It's often the case that a set of machines in your cluster are
privileged in some way. Perhaps they are running special hardware, or
they live in a specific data center, or they have a license to use a
proprietary database. Sometimes, you'll have Onyx jobs that require
tasks to run on a predetermined set of machines. Tags are a feature that
let peers denote "capabilities". Tasks may declare which tags peers must
have in order to be selected to execute them.

==== Peers

To declare a peer as having special capabilities, use a vector of
keywords in the Peer Configuration under key `:onyx.peer/tags`. For
example, if you wanted to declare that a peer has a license for its JVM
to communicate with Datomic, you might add this to your Peer
Configuation:

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>{&#8230;&#8203;
 :onyx/tenancy-id "my-cluster"
 :onyx.peer/tags [:datomic]
 &#8230;&#8203;
}</p>
</div>
<div class="listingblock">
<div class="content">
<pre>You can specify multiple tags. The default is no tags (`[]`), in which
case this peer can execute any tasks that do not require tags.

==== Tasks

Now that we have a means for expressing which peers can do which kinds
of things, we'll need a way to express which tasks require which
capabilities. We do this in the catalog. Any task can use the key
`:onyx/required-tags` with a vector of keywords as a value. Any peer
that executes this task is garunteed to have `:onyx/required-tags` as a
subset of its `:onyx.peer/tags`.

For example, to declare that task `:read-datoms` must be executed by a
peer that can talk to Datomic, you might write:

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>[{:onyx/name :read-datoms
  :onyx/plugin :onyx.plugin.datomic/read-datoms
  :onyx/type :input
  :onyx/medium :datomic
  :onyx/required-tags [:datomic] ;; &#8592; Add this!
  :datomic/uri db-uri
  &#8230;&#8203;
  :onyx/batch-size batch-size
  :onyx/doc "Reads a sequence of datoms from the d/datoms API"}
 &#8230;&#8203;
]</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[[event-subscription]]
== Event Subscription

Onyx's log-based design provides open-ended access to react to all
coordination events. This section describes how to tap into these
notifications.

=== Explanation

Onyx uses an internal log to totally order all coordination events
across nodes in the cluster. This log is maintained as a directory of
sequentially ordered znodes in ZooKeeper. It's often of interest to
watch the events as they are written to the log. For instance, you may
want to know when a particular task is completed, or when a peer joins
or leaves the cluster. You can use the log subscriber to do just that.

=== Subscribing to the Log

The following is a complete example to pretty print all events as they
are written to the log. You need to provide the ZooKeeper address, Onyx
ID, and shared job scheduler in the peer config. The subscriber will
automatically track recover from sequentially reading errors in the case
that a garbage collection is triggered, deleting log entries in its
path.

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def peer-config
  {:zookeeper/address "127.0.0.1:2181"
   :onyx/tenancy-id onyx-id
   :onyx.peer/job-scheduler :onyx.job-scheduler/round-robin})</p>
</div>
<div class="paragraph">
<p>(def ch (chan 100))</p>
</div>
<div class="paragraph">
<p>(def subscription (onyx.api/subscribe-to-log peer-config ch))</p>
</div>
<div class="paragraph">
<p>(def log (:log (:env subscription)))</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<p>Loops forever
(loop [replica (:replica subscription)]
  (let [entry (&lt;!! ch)
        new-replica (onyx.extensions/apply-log-entry entry replica)]
    (clojure.pprint/pprint new-replica)
    (recur new-replica)))</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>(onyx.api/shutdown-env (:env subscription))</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Some example output from a test, printing the log position, log entry
content, and the replica as-of that log entry:

[source,clojure]</pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Log Entry #0
Entry is {:message-id 0, :fn :prepare-join-cluster, :args {:joiner #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"}}
Replica is:
{:peer-state {#uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577" :idle},
 :peers [#uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"],
 :job-scheduler :onyx.job-scheduler/greedy}</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Log Entry #1
Entry is {:message-id 1, :fn :prepare-join-cluster, :args {:joiner #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"}}
Replica is:
{:prepared
 {#uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"},
 :peer-state {#uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577" :idle},
 :peers [#uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"],
 :job-scheduler :onyx.job-scheduler/greedy}</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Log Entry #2
Entry is {:message-id 2, :fn :notify-join-cluster, :args {:observer #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf", :subject #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"}}
Replica is:
{:accepted
 {#uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"},
 :prepared {},
 :peer-state {#uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577" :idle},
 :peers [#uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"],
 :job-scheduler :onyx.job-scheduler/greedy}</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Log Entry #3
Entry is {:message-id 3, :fn :accept-join-cluster, :args {:observer #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf", :subject #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577", :accepted-observer #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577", :accepted-joiner #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"}}
Replica is:
{:pairs
 {#uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577",
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"},
 :accepted {},
 :prepared {},
 :peer-state
 {#uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf" :idle,
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577" :idle},
 :peers
 [#uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"],
 :job-scheduler :onyx.job-scheduler/greedy}</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Log Entry #4
Entry is {:message-id 4, :fn :prepare-join-cluster, :args {:joiner #uuid "010a1688-47ff-4055-8da5-1f02247351e1"}}
Replica is:
{:pairs
 {#uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577",
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"},
 :accepted {},
 :prepared
 {#uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"
  #uuid "010a1688-47ff-4055-8da5-1f02247351e1"},
 :peer-state
 {#uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf" :idle,
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577" :idle},
 :peers
 [#uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"],
 :job-scheduler :onyx.job-scheduler/greedy}</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Log Entry #5
Entry is {:message-id 5, :fn :notify-join-cluster, :args {:observer #uuid "010a1688-47ff-4055-8da5-1f02247351e1", :subject #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"}}
Replica is:
{:pairs
 {#uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577",
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"},
 :accepted
 {#uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"
  #uuid "010a1688-47ff-4055-8da5-1f02247351e1"},
 :prepared {},
 :peer-state
 {#uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf" :idle,
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577" :idle},
 :peers
 [#uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"],
 :job-scheduler :onyx.job-scheduler/greedy}</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Log Entry #6
Entry is {:message-id 6, :fn :accept-join-cluster, :args {:observer #uuid "010a1688-47ff-4055-8da5-1f02247351e1", :subject #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf", :accepted-observer #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577", :accepted-joiner #uuid "010a1688-47ff-4055-8da5-1f02247351e1"}}
Replica is:
{:pairs
 {#uuid "010a1688-47ff-4055-8da5-1f02247351e1"
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf",
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577",
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"
  #uuid "010a1688-47ff-4055-8da5-1f02247351e1"},
 :accepted {},
 :prepared {},
 :peer-state
 {#uuid "010a1688-47ff-4055-8da5-1f02247351e1" :idle,
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf" :idle,
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577" :idle},
 :peers
 [#uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"
  #uuid "010a1688-47ff-4055-8da5-1f02247351e1"],
 :job-scheduler :onyx.job-scheduler/greedy}</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Log Entry #7
Entry is {:message-id 7, :fn :prepare-join-cluster, :args {:joiner #uuid "e6c35131-f4d9-432d-8915-e8616851bb1c"}}
Replica is:
{:pairs
 {#uuid "010a1688-47ff-4055-8da5-1f02247351e1"
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf",
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577",
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"
  #uuid "010a1688-47ff-4055-8da5-1f02247351e1"},
 :accepted {},
 :prepared
 {#uuid "010a1688-47ff-4055-8da5-1f02247351e1"
  #uuid "e6c35131-f4d9-432d-8915-e8616851bb1c"},
 :peer-state
 {#uuid "010a1688-47ff-4055-8da5-1f02247351e1" :idle,
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf" :idle,
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577" :idle},
 :peers
 [#uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"
  #uuid "010a1688-47ff-4055-8da5-1f02247351e1"],
 :job-scheduler :onyx.job-scheduler/greedy}</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Log Entry #8
Entry is {:message-id 8, :fn :notify-join-cluster, :args {:observer #uuid "e6c35131-f4d9-432d-8915-e8616851bb1c", :subject #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"}}
Replica is:
{:pairs
 {#uuid "010a1688-47ff-4055-8da5-1f02247351e1"
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf",
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577",
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"
  #uuid "010a1688-47ff-4055-8da5-1f02247351e1"},
 :accepted
 {#uuid "010a1688-47ff-4055-8da5-1f02247351e1"
  #uuid "e6c35131-f4d9-432d-8915-e8616851bb1c"},
 :prepared {},
 :peer-state
 {#uuid "010a1688-47ff-4055-8da5-1f02247351e1" :idle,
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf" :idle,
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577" :idle},
 :peers
 [#uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"
  #uuid "010a1688-47ff-4055-8da5-1f02247351e1"],
 :job-scheduler :onyx.job-scheduler/greedy}</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Log Entry #9
Entry is {:message-id 9, :fn :accept-join-cluster, :args {:observer #uuid "e6c35131-f4d9-432d-8915-e8616851bb1c", :subject #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf", :accepted-observer #uuid "010a1688-47ff-4055-8da5-1f02247351e1", :accepted-joiner #uuid "e6c35131-f4d9-432d-8915-e8616851bb1c"}}
Replica is:
{:pairs
 {#uuid "e6c35131-f4d9-432d-8915-e8616851bb1c"
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf",
  #uuid "010a1688-47ff-4055-8da5-1f02247351e1"
  #uuid "e6c35131-f4d9-432d-8915-e8616851bb1c",
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577",
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"
  #uuid "010a1688-47ff-4055-8da5-1f02247351e1"},
 :accepted {},
 :prepared {},
 :peer-state
 {#uuid "e6c35131-f4d9-432d-8915-e8616851bb1c" :idle,
  #uuid "010a1688-47ff-4055-8da5-1f02247351e1" :idle,
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf" :idle,
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577" :idle},
 :peers
 [#uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"
  #uuid "010a1688-47ff-4055-8da5-1f02247351e1"
  #uuid "e6c35131-f4d9-432d-8915-e8616851bb1c"],
 :job-scheduler :onyx.job-scheduler/greedy}</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Log Entry #10
Entry is {:message-id 10, :fn :prepare-join-cluster, :args {:joiner #uuid "bf8fd5fc-30fd-424c-af6a-0b32568581a4"}}
Replica is:
{:pairs
 {#uuid "e6c35131-f4d9-432d-8915-e8616851bb1c"
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf",
  #uuid "010a1688-47ff-4055-8da5-1f02247351e1"
  #uuid "e6c35131-f4d9-432d-8915-e8616851bb1c",
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577",
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"
  #uuid "010a1688-47ff-4055-8da5-1f02247351e1"},
 :accepted {},
 :prepared
 {#uuid "010a1688-47ff-4055-8da5-1f02247351e1"
  #uuid "bf8fd5fc-30fd-424c-af6a-0b32568581a4"},
 :peer-state
 {#uuid "e6c35131-f4d9-432d-8915-e8616851bb1c" :idle,
  #uuid "010a1688-47ff-4055-8da5-1f02247351e1" :idle,
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf" :idle,
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577" :idle},
 :peers
 [#uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"
  #uuid "010a1688-47ff-4055-8da5-1f02247351e1"
  #uuid "e6c35131-f4d9-432d-8915-e8616851bb1c"],
 :job-scheduler :onyx.job-scheduler/greedy}</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Log Entry #11
Entry is {:message-id 11, :fn :notify-join-cluster, :args {:observer #uuid "bf8fd5fc-30fd-424c-af6a-0b32568581a4", :subject #uuid "e6c35131-f4d9-432d-8915-e8616851bb1c"}}
Replica is:
{:pairs
 {#uuid "e6c35131-f4d9-432d-8915-e8616851bb1c"
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf",
  #uuid "010a1688-47ff-4055-8da5-1f02247351e1"
  #uuid "e6c35131-f4d9-432d-8915-e8616851bb1c",
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577",
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"
  #uuid "010a1688-47ff-4055-8da5-1f02247351e1"},
 :accepted
 {#uuid "010a1688-47ff-4055-8da5-1f02247351e1"
  #uuid "bf8fd5fc-30fd-424c-af6a-0b32568581a4"},
 :prepared {},
 :peer-state
 {#uuid "e6c35131-f4d9-432d-8915-e8616851bb1c" :idle,
  #uuid "010a1688-47ff-4055-8da5-1f02247351e1" :idle,
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf" :idle,
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577" :idle},
 :peers
 [#uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"
  #uuid "010a1688-47ff-4055-8da5-1f02247351e1"
  #uuid "e6c35131-f4d9-432d-8915-e8616851bb1c"],
 :job-scheduler :onyx.job-scheduler/greedy}</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Log Entry #12
Entry is {:message-id 12, :fn :accept-join-cluster, :args {:observer #uuid "bf8fd5fc-30fd-424c-af6a-0b32568581a4", :subject #uuid "e6c35131-f4d9-432d-8915-e8616851bb1c", :accepted-observer #uuid "010a1688-47ff-4055-8da5-1f02247351e1", :accepted-joiner #uuid "bf8fd5fc-30fd-424c-af6a-0b32568581a4"}}
Replica is:
{:pairs
 {#uuid "bf8fd5fc-30fd-424c-af6a-0b32568581a4"
  #uuid "e6c35131-f4d9-432d-8915-e8616851bb1c",
  #uuid "e6c35131-f4d9-432d-8915-e8616851bb1c"
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf",
  #uuid "010a1688-47ff-4055-8da5-1f02247351e1"
  #uuid "bf8fd5fc-30fd-424c-af6a-0b32568581a4",
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577",
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"
  #uuid "010a1688-47ff-4055-8da5-1f02247351e1"},
 :accepted {},
 :prepared {},
 :peer-state
 {#uuid "bf8fd5fc-30fd-424c-af6a-0b32568581a4" :idle,
  #uuid "e6c35131-f4d9-432d-8915-e8616851bb1c" :idle,
  #uuid "010a1688-47ff-4055-8da5-1f02247351e1" :idle,
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf" :idle,
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577" :idle},
 :peers
 [#uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"
  #uuid "010a1688-47ff-4055-8da5-1f02247351e1"
  #uuid "e6c35131-f4d9-432d-8915-e8616851bb1c"
  #uuid "bf8fd5fc-30fd-424c-af6a-0b32568581a4"
],
 :job-scheduler :onyx.job-scheduler/greedy}</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Log Entry #13
Entry is {:message-id 13, :fn :submit-job, :args {:id #uuid "b784ebb4-356f-4e16-8eac-60e051d69ab7", :tasks [#uuid "ce13205e-937b-4af6-9aa9-d5149b31fb2c" #uuid "948f8595-3a0a-4318-b128-91c1d22c0158" #uuid "fb86b977-d668-4c98-abaa-80ee0d29663a"], :task-scheduler :onyx.task-scheduler/round-robin, :saturation Infinity, :task-saturation {#uuid "ce13205e-937b-4af6-9aa9-d5149b31fb2c" Infinity, #uuid "948f8595-3a0a-4318-b128-91c1d22c0158" Infinity, #uuid "fb86b977-d668-4c98-abaa-80ee0d29663a" Infinity}}}
Replica is:
{:job-scheduler :onyx.job-scheduler/greedy,
 :saturation {#uuid "b784ebb4-356f-4e16-8eac-60e051d69ab7" Infinity},
 :peers
 [#uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"
  #uuid "010a1688-47ff-4055-8da5-1f02247351e1"
  #uuid "e6c35131-f4d9-432d-8915-e8616851bb1c"
  #uuid "bf8fd5fc-30fd-424c-af6a-0b32568581a4"],
 :accepted {},
 :jobs [#uuid "b784ebb4-356f-4e16-8eac-60e051d69ab7"],
 :tasks
 {#uuid "b784ebb4-356f-4e16-8eac-60e051d69ab7"
  [#uuid "ce13205e-937b-4af6-9aa9-d5149b31fb2c"
   #uuid "948f8595-3a0a-4318-b128-91c1d22c0158"
   #uuid "fb86b977-d668-4c98-abaa-80ee0d29663a"]},
 :pairs
 {#uuid "bf8fd5fc-30fd-424c-af6a-0b32568581a4"
  #uuid "e6c35131-f4d9-432d-8915-e8616851bb1c",
  #uuid "e6c35131-f4d9-432d-8915-e8616851bb1c"
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf",
  #uuid "010a1688-47ff-4055-8da5-1f02247351e1"
  #uuid "bf8fd5fc-30fd-424c-af6a-0b32568581a4",
  #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf"
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577",
  #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577"</p>
</div>
<div class="literalblock">
<div class="content">
<pre> #uuid "010a1688-47ff-4055-8da5-1f02247351e1"},
:allocations {#uuid "b784ebb4-356f-4e16-8eac-60e051d69ab7" {}},
:prepared {},
:peer-state
{#uuid "bf8fd5fc-30fd-424c-af6a-0b32568581a4" :idle,
 #uuid "e6c35131-f4d9-432d-8915-e8616851bb1c" :idle,
 #uuid "010a1688-47ff-4055-8da5-1f02247351e1" :idle,
 #uuid "7ad37c45-ce67-4fd4-8850-f3ec58ede0bf" :idle,
 #uuid "b7e5d564-02a3-46d3-863f-c4a2bac7e577" :idle},
:task-schedulers
{#uuid "b784ebb4-356f-4e16-8eac-60e051d69ab7"
 :onyx.task-scheduler/round-robin},
:task-saturation
{#uuid "b784ebb4-356f-4e16-8eac-60e051d69ab7"
 {#uuid "ce13205e-937b-4af6-9aa9-d5149b31fb2c" Infinity,
  #uuid "948f8595-3a0a-4318-b128-91c1d22c0158" Infinity,
  #uuid "fb86b977-d668-4c98-abaa-80ee0d29663a" Infinity}}}</pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[[plugins]]
== Plugins

Plugins serve as an abstract to compose mechanisms for getting data in
and out of Onyx. See the README.md of the project for a list of official
Onyx plugins, or keep reading to roll your own.

=== Interfaces

In order to implement a plugin, one or more protocols need to be
implemented from the
https://github.com/onyx-platform/onyx/blob/0.8.8/src/onyx/peer/pipeline_extensions.clj[Pipeline
Extensions API]. Reader plugins will implement PipelineInput and
Pipeline. Writer plugins will implement Pipeline. See the docstrings for
instructions on implementation.

=== Templates

To help move past the boilerplate of creating new plugins, use Leiningen
with https://github.com/onyx-platform/onyx-plugin[`onyx-plugin`] to
generate a template.

=== Coordination within Plugins

Often virtual peers allocated to a task may need to coordinate with
respect to allocating work. For example, a Kafka reader task may need
to assign partitions to different peers on the same topic. The Onyx
mechanism for coordinating peers is the &lt;&lt;the-log, log&gt;&gt;. The Onyx log
is extensible by plugins, by implementing several extensions
defmethods.

For example:

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(ns your.plugin.log-commands
  (:require [onyx.extensions :as extensions]))</p>
</div>
<div class="paragraph">
<p>(defmethod extensions/apply-log-entry :yourplugin/coordination-type
  [{:keys [args]} replica]
  replica)</p>
</div>
<div class="paragraph">
<p>(defmethod extensions/replica-diff :yourplugin/coordination-type
  [{:keys [args]} old new]
  {})</p>
</div>
<div class="paragraph">
<p>(defmethod extensions/reactions :yourplugin/coordination-type
  [{:keys [args]} old new diff peer-args]
  [])</p>
</div>
<div class="paragraph">
<p>(defmethod extensions/fire-side-effects! :yourplugin/coordination-type
  [{:keys [args]} old new diff {:keys [monitoring] :as state}]
  state)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>When modifying the replica, please assoc-in into replica under
[:task-metadata job-id task-id], so that it will be cleaned up when the
job is completed or killed.
[[onyx-core-async]]

== onyx-core-async

Onyx plugin providing read and write facilities for Clojure core.async.

=== Installation

This plugin is included with Onyx. You do not need to add it as a
separate dependency.

In your peer boot-up namespace:

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(:require [onyx.plugin.core-async])</p>
</div>
<div class="listingblock">
<div class="content">
<pre>=== Functions

==== read-from-chan

Catalog entry:

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>{:onyx/name :in
 :onyx/plugin :onyx.plugin.core-async/input
 :onyx/type :input
 :onyx/medium :core.async
 :onyx/batch-size batch-size
 :onyx/max-peers 1
 :onyx/doc "Reads segments from a core.async channel"}</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Lifecycle entries:

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>[{:lifecycle/task :your-task-name
  :lifecycle/calls :my.ns/in-calls}
 {:lifecycle/task :your-task-name
  :lifecycle/calls :onyx.plugin.core-async/reader-calls}]</p>
</div>
<div class="listingblock">
<div class="content">
<pre>There's a little extra baggage with core.async because you need a
reference to the channel. Make sure that `my.ns/in-calls` is a map that
references a function to inject the channel in:

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def in-chan (chan capacity))</p>
</div>
<div class="paragraph">
<p>(defn inject-in-ch [event lifecycle]
  {:core.async/chan in-chan})</p>
</div>
<div class="paragraph">
<p>(def in-calls
  {:lifecycle/before-task-start inject-in-ch})</p>
</div>
<div class="listingblock">
<div class="content">
<pre>==== write-to-chan

Catalog entry:

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>{:onyx/name :out
 :onyx/plugin :onyx.plugin.core-async/output
 :onyx/type :output
 :onyx/medium :core.async
 :onyx/batch-size batch-size
 :onyx/max-peers 1
 :onyx/doc "Writes segments to a core.async channel"}</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Lifecycle entries:

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>[{:lifecycle/task :your-task-name
  :lifecycle/calls :my.ns/out-calls}
 {:lifecycle/task :your-task-name
  :lifecycle/calls :onyx.plugin.core-async/writer-calls}]</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Again, as with `read-from-chan`, there's a little extra to do since
core.async has some exceptional behavior compared to other plugins:

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(def out-chan (chan capacity))</p>
</div>
<div class="paragraph">
<p>(defn inject-out-ch [event lifecycle]
  {:core.async/chan out-chan})</p>
</div>
<div class="paragraph">
<p>(def out-calls
  {:lifecycle/before-task-start inject-out-ch})</p>
</div>
<div class="listingblock">
<div class="content">
<pre>=== Utility Functions

==== `take-segments!`

This additional function is provided as a utility for removing segments
from a channel until `:done` is found. After `:done` is encountered, all
prior segments, including `:done`, are returned in a seq.
[[logging]]
== Logging

This chapter details how to inspect and modify the logs that Onyx
produces.

=== Timbre

Onyx uses https://github.com/ptaoussanis/timbre[Timbre] for logging.

By default, all Onyx output is logged to a file called `onyx.log` in the
same directory as where the peer or coordinator jar is executing. The
logging configuration can be overridden completely, see below.

Onyx's default logging configuration writes all `WARN` and `FATAL`
messages to standard out, also.

==== Overriding the log file name and path

In order to override the log file location add `:onyx.log/file` to both
the environment config sent into `start-env` as well as the peer config
sent into `start-peer-group`.

Both relative and absolute paths are supported by Timbre.

==== Overriding the Timbre log config

Similarly, to override the full Timbre log config map, construct the
Timbre configuration and add it to both the environment and peer config
maps under the `:onyx.log/config` key. Note that the `onyx.log/config`
map will be merged with the existing Timbre configuration rather than
replacing it completely. In practice this means that extra configuration
must be sent in to, for example, disable appenders that are enabled by
default. See the examples below.

==== Examples

The following example simply changes the output file.

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(let [log-config {:onyx.log/file "/var/log/onyx.log"}
      peer-config (merge my-peer-config log-config)
      env-config (merge my-env-config log-config)]
  (onyx.api/start-env env-config)
  (onyx.api/start-peer-group peer-config)</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<p>&#8230;&#8203;
)</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre>This example uses Timbre to redirect Onyx logs into the regular Java
logging system using the
https://github.com/palletops/log-config[log-config] library.

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(require '[com.palletops.log-config.timbre.tools-logging :as tl])
(let [log-config {:onyx.log/config {:appenders
                                    {:spit {:enabled? false}
                                     :standard-out {:enabled? false}
                                     :rotor {:enabled? false}
                                     :jl (tl/make-tools-logging-appender
                                          {:enabled? true
                                           :fmt-output-opts {:nofonts? true}})}
                                    :min-level :trace}}
      peer-config (merge my-peer-config log-config)
      env-config (merge my-env-config log-config)]
  (onyx/start-env env-config)
  (onyx/start-peer-group peer-config)</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<p>&#8230;&#8203;
)</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre>If you already have timbre logging configured somewhere in your code
base, you can specify `:onyx.log/config {}` to ensure your settings
remain unchanged. In effect, this simply merges in the empty map into
whatever settings you may have already specified for logging.

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(let [log-config {:onyx.log/config {}}
      peer-config (merge my-peer-config log-config)
      env-config (merge my-env-config log-config)]
  (onyx.api/start-env env-config)
  (onyx.api/start-peer-group peer-config)</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<p>&#8230;&#8203;
)</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre>See the Timbre
link:++https://github.com/ptaoussanis/timbre#configuration++[example
configuration] for more information on valid values for the
`:onyx.log/config` map.
[[examples]]

== Examples

=== Examples Project

See the https://github.com/onyx-platform/onyx-examples[Examples Project] for a set of self-contained demonstrations of specific Onyx functionality.
[[frequently-asked-questions]]

== Frequently Asked Questions

=== My job's tasks never start

When your job's tasks don't start, you won't see any messages in
`onyx.log` on the peer that read something like:

....
Job fb2f2b80-2c5a-41b6-93c8-df35bffe6915 {:job-name :click-stream} - Task da5795a6-bd4c-41a1-843d-dda84cf5c615 :inc - Peer 2b35433a-b935-43b7-881b-4f4ec16672cc - Warming up task lifecycle {:id =uuid "da5795a6-bd4c-41a1-843d-dda84cf5c615", :name :inc, :egress-ids {:out =uuid "2c210c3e-6411-45fb-85a7-6cc733118215"}}
....

Instead, the log would show peers starting, but not doing anything. This
looks like something:

....
Starting Virtual Peer 111dcc44-7f53-41a4-8548-047803e8d441
....

==== Resolutions

===== Do you have enough virtual peers provisioned?

When a job is submitted to Onyx, it will only begin when there are
enough virtual peers to sustain its execution. How many are __enough__?
That depends. One virtual peer may work on _at most_ one task at any
given time. By default, each task in your workflow requires _one_
available virtual peer to run it. If a grouping task is used, or if you
set `:onyx/min-peers` on the task's catalog entry, the number may be
greater than 1. You can statically determine how many peers a job needs
for execution with
https://github.com/onyx-platform/onyx/blob/c311e4034897d5693e046e8223c66fcbd478312d/src/onyx/test_helper.clj=L33-L41[this
simple helper function] available in Onyx core.

As an example, if you submit a job with 10 tasks in its workflow, you
need _at least_ 10 available virtual peers for your job to begin
running. If you only have 8, nothing will happen. If you have more than
10 (assuming that 10 is truly the minimum that you need), Onyx may
attempt to dedicate more resources to your job beyond 10 peers,
depending on which scheduler you used You can control the number of
virtual peers that you're running by modifying the parameters to
`onyx.api/start-peers`.

We don't emit a warning that your cluster is underprovisioned in terms
of number of peers because its masterless design makes this difficult to
asynchronously detect. This has been discussed
https://github.com/onyx-platform/onyx/issues/452[in an issue]. Onyx is
designed to handle under and over provisioning as part of its normal
flow, so this is not considered an error condition.

See the &lt;&lt;scheduling,Scheduling chapter&gt;&gt; of the User Guide for a full explanation.

===== Are you using the Greedy job scheduler?

You've hit this case if you have more than one job running concurrently.
When you start your peers, you specified a job scheduler through the
configuration key `:onyx.peer/job-scheduler`. If you specified
`:onyx.job-scheduler/greedy`, you've asked that Onyx dedicate _all_
cluster resources to the first submitted job until that job is
completed. Then the job is completed, all resources will be assigned to
the next job available, and so on. If you want more than one job running
at a time, consider using the Balanced (`onyx.job-scheduler/balanced`)
or Percentage (`onyx.job-scheduler/percentage`) job schedulers. See the
Scheduling chapter of this User Guide for a full explanation.

=== Peers repeatedly echo that they're warming up

If you see something like the following repeatedly being written to
`onyx.log`, you're in the right place:

....
Job fb2f2b80-2c5a-41b6-93c8-df35bffe6915 {:job-name :click-stream} - Task 2c210c3e-6411-45fb-85a7-6cc733118215 :out - Peer 3b2c6667-8f41-47a9-ba6b-f97c81ade828 - Peer chose not to start the task yet. Backing off and retrying...
....

What's happening here is that your job's tasks have started execution.
Peers have been assigned tasks, and are beginning to get things in order
to perform work on them. Before a peer can truly begin running a task,
it must do three things:

1.  Call all lifecycle hooks registered under `lifecycle/start-task?`
sequentially, accruing their results
2.  Call the constructor for the input or output plugin, if this is an
input or output task.
3.  Emit a signal back to ZooKeeper indicating that this peer has opened
up all of its sockets to receiving incoming communication from other
peers.

The results from the first step are a sequence of boolean values
designating whether the peer is allowed to start this task. If _any_ of
the `start-task?` lifecycle calls return false, the peer sleeps for a
short period to back off, then performs step 1 again. This process
continues until all lifecycle calls return true. Read the Lifecycles
chapter of this User Guide to learn why it's useful to be repeatedly try
and back-off from task launching.

The second step will only occur after step 1 successfully completes -
that is, all lifecycle functions return true. The reason you see
"Backing off and retrying..." in the logs is because step 1 is being
repeated again.

==== Resolutions

===== Do all your `:lifecycle/start-task?` functions eventually return
`true`?

If any of your lifecycle hooks for `:lifecycle/start-task?` return
`false` or `nil`, you'll want to change them to eventually return `true`
based upon some condition.

===== Are the connections that your plugin opens valid?

As per step 2, a plugin's constructor will be called to open any
relevant stateful connections, such as a database or socket connection.
Many connection calls, such as a JDBC SQL, will block for prolonged
periods of time before failing, unless otherwise configured. If the task
that appears to be stuck is an input or output task, this is likely the
cause. You may want to reconfigure your initial connections to fail
faster to make it more obvious as to what's happening.

=== None of my messages are being processed

If you're `onyx.log` shows messages that read as follows, your job's
tasks have successfully started:

....
Job fb2f2b80-2c5a-41b6-93c8-df35bffe6915 {:job-name :click-stream} - Task da5795a6-bd4c-41a1-843d-dda84cf5c615 :inc - Peer 2b35433a-b935-43b7-881b-4f4ec16672cc - Enough peers are active, starting the task
....

If you suspect that messages are not being processed, it heavily depends
on the input plugin that you're using.

==== Resolutions

===== Try using `:onyx/fn` to log all incoming messages

One thing that you can do for extra visibility is to log all incoming
messages from input tasks. This is inadvisable for production, but can
be useful for temporary debugging. You can specify an `:onyx/fn`
transformation function to _any_ task, including inputs and outputs. It
can be useful to specify a debug function on your input tasks to see
which messages are entering the system. Be sure that this function
returns the original segment! For example, you can define a function:

[source,clojure]</pre>
</div>
</div>
<div class="paragraph">
<p>(defn spy [segment]
  (println "Read from input:" segment)
  segment)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Then add `:onyx/fn ::spy` to your input catalog entries.

===== Has your job been killed?

Unless otherwise configured by your Lifecycles, if any user-level code
throws an exception, the job will be killed and is no longer elligible
for execution. Check `onyx.log` on all your peers to ensure that no
exceptions were thrown. If this were the case, you'd see messages lower
in the log reading:

....
Job fb2f2b80-2c5a-41b6-93c8-df35bffe6915 {:job-name :click-stream} - Task 1e83e005-3e2d-4307-907b-a3d66e3aa293 :in - Peer 111dcc44-7f53-41a4-8548-047803e8d441 - Stopping task lifecycle
....

===== Are you using the Kafka input plugin?

If you're using the Kafka input plugin, make sure that you're reading
from a reasonable starting offset of the topic. If you've set
`:kafka/force-reset?` to `true` in the catalog entry, and you've also
set `:kafka/offset-reset` to `:largest`, you've instructed Onyx to begin
reading messages from the _end_ of the topic. Until you place more
messages into the topic, Onyx will sit idle waiting for more input. The
starting offset for each input task using Kafka is echoed out in
`onyx.log`.

=== The same messages are being replayed multiple times

Message replay happens when a message enters Onyx from an input source,
gets processed, and is seen again at a later point in time. Onyx replays
messages for fault tolerance when it suspects that failure of some sort
has occurred. You can read about how message replay is implemented, and
why it is exists, in the Architecture chapter of this User Guide.

There are many reasons why a message may _need_ to be replayed (every
possible failure scenario), so we will limit our discussion to
controlling replay frequency. See the performance tuning sections of
this document for more context about what value is appropriate to set
for the replay frequency.

==== Resolutions

===== Is your `:onyx/pending-timeout` too low?

Messages are replayed from the input source if they do not complete
their route through the cluster within a particular period of time. This
period is controlled by the `:onyx/pending-timeout` parameter to the
catalog entry, and it's default is 60 seconds. You can read about its
specifics
link:++http://www.onyxplatform.org/docs/cheat-sheet/latest/#/catalog-entry/:onyx/pending-timeout++[in
the Cheatsheet]. You should set this value high enough such that any
segment taking longer than this value to complete is highly likely to
have encountered a failure scenario.

=== My program starts running, but then it stalls

Programs that begin healthy by processing messages and then stall are
out typically indicative of user-level code problems. We outline a few
common cases here.

==== Resolutions

===== Does onyx.log have any exceptions in it?

Most exceptions will kill the job in question. If you are simply
monitoring progress by reading from an output data source through Onyx,
you should check all of the peer `onyx.log` files for exceptions that
may have killed the job.

===== Are any user-level functions blocking?

Any implementations of `:onyx/fn` that are blocking will halt progress
of all other segments that are directly lined up behind it. Ensure that
user level functions finish up in a timely manner.

===== Are messages being replayed?

To get started, see the full section on how and why messages are being
replayed. In short, messages will be replayed in 60 seconds if they are
not completed. You may be experiencing initial success, followed by a
runtime error that is causing temporarily lost segments before replay.

===== Are you using a core.async output plugin?

If you're using a core.async output plugin writing to a channel that
will _block_ writes when the buffer is full, you have run enough
messages to put onto the channel such that core.async writes are now
blocking, and hence stalling Onyx.

===== Are your peer hosts and ports advertised correctly?

Ensure that the host and port that the peer advertises to the rest of
the cluster for incoming connections is correct. If it is incorrect,
only tasks that are colocated on the same machine will have a chance of
working. Remember that Onyx uses UDP as its port, so make sure that your
security settings are allowing traffic to run through that protocol.

The host is configured via the `:onyx.messaging/bind-addr` key, and the
port is configured via the `:onyx.messaging/peer-port` key.

=== Peer fails to start, and throws
`java.io.IOException: No space left on device`

This exception commonly occurs when running Onyx inside of a Docker
container. Aeron requires more shared memory than the container
allocates by default. You can solve this problem by starting your
container with a larger amount of shared memory by specifying
`--shm-size` on Docker &gt;= 1.10.

=== Aeron Mediadriver crashes the JVM with SIGBUS

This exception can occur when Aeron does not have enough shared memory. Increase the amount of shared memory that is set as described above.

=== Peer fails to start, and throws
`org.apache.bookkeeper.bookie.BookieException$InvalidCookieException: Cookie`

This exception occurs due to a bug in BookKeeper reconnection to
ZooKeeper before it's ephemeral node expires. We are currently surveying
our own workarounds until this is patched, but for now the thing to do
is to delete `/tmp/bookkeeper_journal` and `/tmp/bookkeeper_ledger` on
the host. Restart the peer, and all will be well.

=== Peer fails to start, and throws
`java.lang.IllegalStateException: aeron cnc file version not understood`

This exception occurs when Aeron's version is upgraded or downgraded
between incompatible versions. The exception will also provide a path on
the OS to some Aeron files. Shutdown the peer, delete that directory,
then restart the peer.

=== Peer fails to start, and throws
`Failed to connect to the Media Driver - is it currently running?`

This message is thrown when the peer tries to start, but can't engage
Aeron in its local environment. Aeron can be run in embedded mode by
switching `:onyx.messaging.aeron/embedded-driver?` to `true`, or by
running it out of process on the peer machine, which is the recommended
production setting. If you're running it out of process, ensure that it
didn't go down when you encounter this message. You should run Aeron
through a process monitoring tool such as `monit` when running it out of
process.

=== Peer fails to start, and throws
`uk.co.real_logic.aeron.driver.exceptions.ActiveDriverException: active driver detected`

You have encountered the following exception:

....
uk.co.real_logic.aeron.driver.exceptions.ActiveDriverException: active driver detected
  clojure.lang.ExceptionInfo: Error in component :messaging-group in system onyx.system.OnyxPeerGroup calling ='com.stuartsierra.component/start
....

This is because you have started your peer-group twice without shutting
it down. Alternatively, you may be using
`:onyx.messaging.aeron/embedded-driver? true` in your peer-group and
starting a media driver externally. Only one media driver can be started
at a time.

=== Application fails to build uberjar, throw
'java.lang.unsupporteclassversionerror:
uk.co.real_logic/aeron/Aeron$context unsupported major.minor version
52.0'

You have encountered the following exception:

....
java.lang.unsupporteclassversionerror: uk.co.real_logic/aeron/Aeron$context unsupported major.minor version 52.0
....

This is because you are trying to build/run an Onyx app with a JRE
version lower than 1.8. Onyx supports Java 1.8 only.

=== Peer fails to start, and throws
`org.apache.bookkeeper.proto.WriteEntryProcessorV3: Error writing entry:X to ledger:Y`

You have encountered the following exception:

....
2015-12-16 16:59:35 ERROR org.apache.bookkeeper.proto.WriteEntryProcessorV3: Error writing entry:0 to ledger:2
org.apache.bookkeeper.bookie.Bookie$NoLedgerException: Ledger 2 not found
....

Your ZooKeeper directory has been cleared out of information that points
to the BookKeeper servers, and the two processes can't sync up. This can
be fixed by removing the data directory from the BookKeeper servers and
ZooKeeper servers.

=== My program begins running, but throws
`No implementation of method: :read-char of protocol: ='clojure.tools.reader.reader-types/Reader found for class`

You'll encounter this exception when your `:onyx/fn` returns something
that is not EDN and Nippy serializable, which is required to send it
over the network. Ensure that return values from `:onyx/fn` return
either a map, or a vector of maps. All values within must be EDN
serializable.

=== What does Onyx use internally for compression by default?

Unless otherwise overridden in the Peer Pipeline API, Onyx will use
https://github.com/ptaoussanis/nippy[Nippy]. This can be override by
setting the peer configuration with `:onyx.messaging/compress-fn` and
`:onyx.messaging/decompress-fn`. See the Information Model documentation
for more information.

=== How can I filter segments from being output from my tasks?

Use Flow Conditions or return an empty vector from your `:onyx/fn`.

=== Can I return more than one segment from a function?

Return a vector of maps from `:onyx/fn` instead of a map. All maps at
the top level of the vector will be unrolled and pushed downstream.

=== Should I be worried about `user-level KeeperException` in ZooKeeper
logs?

You should monitor these, however `KeeperErrorCode = NodeExists` are
probably fine:

....
2015-11-05 15:12:51,332 [myid:] - INFO  [ProcessThread(sid:0 cport:-1)::PrepRequestProcessor@645] - Got user-level KeeperException when processing sessionid:0x150d67d0cd10003 type:create cxid:0xa zxid:0x50 txntype:-1 reqpath:n/a Error Path:/onyx/0e14715d-51b9-4e2b-af68-d5292f276afc/windows Error:KeeperErrorCode = NodeExists for /onyx/0e14715d-51b9-4e2b-af68-d5292f276afc/windows
....

This is a peer just trying to recreate a ZooKeeper path that was already
created by another peer, and it can be safely ignored.

=== How should I benchmark on a single machine?

Definitely turn off messaging short circuiting, as messaging short
circuiting will improve performance in a way that is unrealistic for
multi-node use. Remember to turn messaging short circuiting back on for
production use, as it _does_ improve performance overall.</pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2017-02-08 14:48:09 PST
</div>
</div>
</body>
</html>