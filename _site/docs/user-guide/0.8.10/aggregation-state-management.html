<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Aggregation and State</title>
  <meta name="description" content="Distributed, masterless, high performance, fault tolerant data processing
">

  <script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	  ga('create', 'UA-72807409-1', 'auto');
	  ga('send', 'pageview');
  </script>

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/lavish-bootstrap.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/cheat-sheet-style.css">
  <link rel="canonical" href="http://www.onyxplatform.org/docs/user-guide/0.8.10/aggregation-state-management.html">
  <link rel="alternate" type="application/rss+xml" title="Onyx" href="http://www.onyxplatform.org/feed.xml" />
</head>



  <body>
    <header class="site-header">
  <div class="container-fluid">
    <div class="row">
      <div class="col-md-2"></div>
      <div class="col-md-1">
        <h2><a id="nav-title" href="/">Onyx</a></h2>
      </div>
      <div class="col-md-1"></div>
      <div class="col-md-6">
        <ul class="nav nav-pills navbar-right">
          <li class="nav-choice" role="presentation"><a href="/learn">learn</a></li>
          <li class="nav-choice" role="presentation"><a href="/docs">docs</a></li>
          <li class="nav-choice" role="presentation"><a href="/tools">tools</a></li>
          <li class="nav-choice" role="presentation"><a href="/blog">blog</a></li>
          <li class="nav-choice" role="presentation"><a href="https://github.com/onyx-platform/onyx">github</a></li>
          <li class="nav-choice" role="presentation"><a href="/support">support</a></li>
          <li class="nav-choice" role="presentation"><a href="/team">team</a></li>
        </ul>
      </div>
      <div class="col-md-2"></div>
    </div>
  </div>
</header>

    <div class="container-fluid">
  <div class="row">
    <div class="col-md-2 panel page-contents">
      <h4>Contents</h4>
      <ul>
  <li><a href="/docs/cheat-sheet/latest">cheat sheet</a></li>
  <li><a href="/docs/api/0.8.10">api docs</a></li>
  <li>user guide</li>
  <ul>
    
    
    
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/latest/aggregation-state-management.html">Aggregation and State</a></li>
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/latest/apis.html">APIs</a></li>
    
    
    
    
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/latest/architecture-low-level-design.html">Architecture</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/latest/backpressure.html">Backpressure</a></li>
    
    
    
    
    
    
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/latest/concepts.html">Concepts</a></li>
    
    
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/latest/core-async-plugin.html">core.async Plugin</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/latest/deployment.html">Deployment</a></li>
    
    
    
    
    
    
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/latest/environment.html">Environment</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/latest/examples.html">Examples</a></li>
    
    
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/latest/faq.html">FAQ</a></li>
    
    
    
    
    
    
    
    
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/latest/flow-conditions.html">Flow Conditions</a></li>
    
    
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/latest/functions.html">Functions</a></li>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/latest/information-model.html">Information Model</a></li>
    
    
    
    
    
    
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/latest/lifecycles.html">Lifecycles</a></li>
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/latest/logging.html">Logging</a></li>
    
    
    
    
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/latest/messaging.html">Messaging</a></li>
    
    
    
    
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/latest/monitoring.html">Monitoring</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/latest/peer-config.html">Peer Configuration</a></li>
    
    
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/latest/performance-tuning.html">Performance Tuning</a></li>
    
    
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/latest/plugins.html">Plugins</a></li>
    
    
    
    
    
    
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/latest/production-check-list.html">Production Checklist</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/latest/scheduling.html">Scheduling</a></li>
    
    
    
    
    
    
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/latest/subscription.html">Subscription</a></li>
    
    
    
    
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/latest/testing-onyx-jobs.html">Testing Onyx Jobs</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/latest/triggers.html">Triggers</a></li>
    
    
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/latest/what-does-it-offer.html">What does it Offer?</a></li>
    
    
    
    
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/latest/windowing.html">Windowing</a></li>
    
    
    
    
  </ul>
</ul>

    </div>
    <div class="col-md-1"></div>
    <div class="col-md-7 panel">
      <h2 id="aggregation--state-management">Aggregation / State Management</h2>

<p>This section discusses state management and fault tolerance used in windowing/streaming joins.</p>

<h3 id="summary">Summary</h3>

<p>Onyx provides the ability to perform updates to a state machine for segments<br />
which are calculated over <a href="/docs/user-guide/0.8.10/windowing.html">windows</a>. For example,<br />
a grouping task may accumulate incoming values for a number of keys over<br />
windows of 5 minutes. This feature is commonly used for aggregations, such as<br />
summing values, though it can be used to build more complex state machines.</p>

<h4 id="state-example">State Example</h4>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>
<span style="color:#777">;; Task definition</span>
{<span style="color:#A60">:onyx/name</span> <span style="color:#A60">:sum-all-ages</span>
 <span style="color:#A60">:onyx/fn</span> <span style="color:#A60">:clojure.core/identity</span>
 <span style="color:#A60">:onyx/type</span> <span style="color:#A60">:function</span>
 <span style="color:#A60">:onyx/group-by-key</span> <span style="color:#A60">:name</span>
 <span style="color:#A60">:onyx/flux-policy</span> <span style="color:#A60">:recover</span>
 <span style="color:#A60">:onyx/min-peers</span> <span style="color:#00D">2</span>
 <span style="color:#A60">:onyx/batch-size</span> <span style="color:#00D">20</span>}

<span style="color:#777">;; Window definition</span>
{<span style="color:#A60">:window/id</span> <span style="color:#A60">:sum-all-ages-window</span>
 <span style="color:#A60">:window/task</span> <span style="color:#A60">:sum-all-ages</span>
 <span style="color:#A60">:window/type</span> <span style="color:#A60">:global</span>
 <span style="color:#A60">:window/aggregation</span> [<span style="color:#A60">:your-sum-ns/sum</span> <span style="color:#A60">:age</span>]
 <span style="color:#A60">:window/window-key</span> <span style="color:#A60">:event-time</span>
 <span style="color:#A60">:window/range</span> [<span style="color:#00D">1</span> <span style="color:#A60">:hour</span>]
 <span style="color:#A60">:window/doc</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Adds the :age key in all segments in 1 hour fixed windows</span><span style="color:#710">&quot;</span></span>}
</pre></div>
</div>
</div>

<p>As segments are processed, an internal state within the calculated window is<br />
updated. In this case we are trying to sum the ages of the incoming segments.</p>

<p>Window aggregations are defined by a map containing the following keys:</p>

<table>
  <thead>
    <tr>
      <th>Key</th>
      <th>Optional?</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>:aggregation/init</code></td>
      <td>true</td>
      <td>Fn (window) to initialise the state.</td>
    </tr>
    <tr>
      <td><code>:aggregation/fn</code></td>
      <td>false</td>
      <td>Fn (state, window, segment) to generate a serializable state machine update.</td>
    </tr>
    <tr>
      <td><code>:aggregation/apply-state-update</code></td>
      <td>false</td>
      <td>Fn (state, entry) to apply state machine update entry to a state.</td>
    </tr>
    <tr>
      <td><code>:aggregation/super-aggregation-fn</code></td>
      <td>true</td>
      <td>Fn (state-1, state-2, window) to combine two states in the case of two windows being merged.</td>
    </tr>
  </tbody>
</table>

<p>In the <code>:window/aggregation</code> map in the <code>:sum-all-ages</code> window referenced above.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>(<span style="color:#080;font-weight:bold">ns</span> <span style="color:#707;font-weight:bold">your-sum-ns</span>)

(<span style="color:#080;font-weight:bold">defn</span> <span style="color:#06B;font-weight:bold">sum-init-fn</span> [window]
  <span style="color:#00D">0</span>)

(<span style="color:#080;font-weight:bold">defn</span> <span style="color:#06B;font-weight:bold">sum-application-fn</span> [state [changelog-type value]]
  (<span style="color:#080;font-weight:bold">case</span> changelog-type
    <span style="color:#A60">:set-value</span> value))

(<span style="color:#080;font-weight:bold">defn</span> <span style="color:#06B;font-weight:bold">sum-aggregation-fn</span> [state window segment]
  <span style="color:#777">; k is :age</span>
  (<span style="color:#080;font-weight:bold">let</span> [k (<span style="color:#080;font-weight:bold">second</span> (<span style="color:#A60">:window/aggregation</span> window))]
    [<span style="color:#A60">:set-value</span> (<span style="color:#080;font-weight:bold">+</span> state (<span style="color:#080;font-weight:bold">get</span> segment k))]))

<span style="color:#777">;; sum aggregation referenced in window definition.</span>
(<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">sum</span>
  {<span style="color:#A60">:aggregation/init</span> sum-init-fn
   <span style="color:#A60">:aggregation/fn</span> sum-aggregation-fn
   <span style="color:#A60">:aggregation/apply-state-update</span> sum-application-fn})
    
</pre></div>
</div>
</div>

<p>Let’s try processing some example segments using this aggregation:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>[{<span style="color:#A60">:name</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">John</span><span style="color:#710">&quot;</span></span> <span style="color:#A60">:age</span> <span style="color:#00D">49</span>}
 {<span style="color:#A60">:name</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Madeline</span><span style="color:#710">&quot;</span></span> <span style="color:#A60">:age</span> <span style="color:#00D">55</span>}
 {<span style="color:#A60">:name</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Geoffrey</span><span style="color:#710">&quot;</span></span> <span style="color:#A60">:age</span> <span style="color:#00D">14</span>}]
</pre></div>
</div>
</div>

<p>Results in the following events:</p>

<table>
  <thead>
    <tr>
      <th>Action</th>
      <th>Result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Initial state</td>
      <td><code>0</code></td>
    </tr>
    <tr>
      <td>Incoming segment</td>
      <td><code>{:name "John" :age 49}</code></td>
    </tr>
    <tr>
      <td>Changelog entry</td>
      <td><code>[:set-value 49]</code></td>
    </tr>
    <tr>
      <td>Applied to state</td>
      <td><code>49</code></td>
    </tr>
    <tr>
      <td>Incoming segment</td>
      <td><code>{:name "Madeline" :age 55}</code></td>
    </tr>
    <tr>
      <td>Changelog entry</td>
      <td><code>[:set-value 104]</code></td>
    </tr>
    <tr>
      <td>Applied to state</td>
      <td><code>104</code></td>
    </tr>
    <tr>
      <td>Incoming segment</td>
      <td><code>{:name "Geoffrey" :age 14}</code></td>
    </tr>
    <tr>
      <td>Changelog entry</td>
      <td><code>[:set-value 128]</code></td>
    </tr>
    <tr>
      <td>Applied to state</td>
      <td><code>128</code></td>
    </tr>
  </tbody>
</table>

<p>This state can be emitted via triggers or another mechanism. By describing<br />
changelog updates as a vector with a log command, such as <code>:set-value</code><br />
aggregation function can emit multiple types of state transition if necessary.</p>

<h3 id="fault-tolerance">Fault Tolerance</h3>

<p>To allow for full recovery after peer crashes, the window state must be replicated<br />
somewhere. As state updates occur, Onyx publishes the stream of changelog<br />
updates to a replicated log.</p>

<p>After the changelog entry is written to the replicated log, the segment is<br />
acked, ensuring that a segment is only cleared from the input source after the<br />
update to window states it caused has been fully written to the log. When a<br />
peer crash occurs, a new peer will be assigned to the task, and this peer will<br />
play back all of the changelog entries, and apply them to the state, starting<br />
with the initial state. As the changelog updates are read back in the same<br />
order that they were written, the full state will be recovered. Partial updates<br />
ensure that only minimal update data is written for each segment processed,<br />
while remaining correct on peer failure.</p>

<h3 id="exactly-once-aggregation-updates">Exactly Once Aggregation Updates</h3>

<p>Exactly once aggregation updates are supported via Onyx’s filtering feature. When a<br />
task’s catalog has <code>:onyx/uniqueness-key</code> set, this key is looked up in the<br />
segment and used as an ID key to determine whether the segment has been seen<br />
before. If it has previously been processed, and state updates have been<br />
persisted, then the segment is not re-processed. This key is persisted to the<br />
state log transactionally with the window changelog updates, so that previously seen keys<br />
can be recovered in case of a peer failure.</p>

<p><strong>See the section “Exactly Once Side-Effects” for discussion of why<br />
side-effects are impossible to achieve Exactly Once</strong>.</p>

<h4 id="considerations">Considerations</h4>

<p>In order to reduce memory consumption, uniqueness-key values are persisted to a<br />
local database, currently implemented with RocksDB. This database uses a bloom<br />
filter, and a memory cache, allowing Onyx to avoid hitting disk<br />
for most filter key checks.</p>

<p>In order to prevent unbounded increase in the size of the filter’s disk<br />
consumption, uniqueness-key values are bucketed based on recency, and the<br />
oldest bucket is expired as the newest is filled.</p>

<p>Several configuration parameters are available for the rocksdb based local<br />
filter. The most relevant of these for general configuration is<br />
<code>:onyx.rocksdb.filter/num-ids-per-bucket</code>, and <code>:onyx.rocksdb.num-buckets</code>,<br />
which are the size and the number of buckets referenced above.</p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>:onyx.rocksdb.filter/peer-block-cache-size</code></td>
      <td>RocksDB block cache size in bytes. Larger caches reduce the chance that the peer will need to check for the prescence of a uniqueness key on disk. Defaults to 100MB.</td>
      <td>104857600</td>
    </tr>
    <tr>
      <td><code>:onyx.rocksdb.filter/bloom-filter-bits</code></td>
      <td>Number of bloom filter bits to use per uniqueness key value</td>
      <td>10</td>
    </tr>
    <tr>
      <td><code>:onyx.rocksdb.filter/num-ids-per-bucket</code></td>
      <td>Number of uniqueness key values that can exist in a RocksDB filter bucket.</td>
      <td>10000000</td>
    </tr>
    <tr>
      <td><code>:onyx.rocksdb.filter/num-buckets</code></td>
      <td>Number of rotating filter buckets to use. Buckets are rotated every <code>:onyx.rocksdb.filter/num-ids-per-bucket</code>, with the oldest bucket being discarded if num-buckets already exist.</td>
      <td>10</td>
    </tr>
    <tr>
      <td><code>:onyx.rocksdb.filter/block-size</code></td>
      <td>RocksDB block size. May worth being tuned depending on the size of your uniqueness-key values.</td>
      <td>4096</td>
    </tr>
    <tr>
      <td><code>:onyx.rocksdb.filter/compression</code></td>
      <td>Whether to use compression in rocksdb filter. It is recommended that <code>:none</code> is used unless your uniqueness keys are large and compressible.</td>
      <td><code>:none</code></td>
    </tr>
    <tr>
      <td><code>:onyx.rocksdb.filter/base-dir</code></td>
      <td>Temporary directory to persist uniqueness filtering data.</td>
      <td>/tmp/rocksdb_filter</td>
    </tr>
  </tbody>
</table>

<h4 id="exactly-once-side-effects">Exactly Once Side-Effects</h4>

<p>Exactly once <em>side-effects</em> resulting from a segment being processed may occur,<br />
as exactly once side-effects are impossible to achieve. Onyx guarantees that a<br />
window state updates resulting from a segment are perfomed exactly once,<br />
however any side-effects that occur as a result of the segment being processed<br />
cannot be guaranteed to only occur once.</p>

<h3 id="bookkeeper-implementation">BookKeeper Implementation</h3>

<p>State update changelog entries are persisted to BookKeeper, a replicated log<br />
server. An embedded BookKeeper server is included with Onyx. The embedded<br />
server is currently the recommended approach to running BookKeeper along side<br />
Onyx. This will be re-evaluated in the beta release of Onyx 0.8.0.</p>

<p>BookKeeper ensures that changelog entries are replicated to multiple nodes,<br />
allowing for the recovery of windowing states upon the crash of a windowed task<br />
task.</p>

<p>By default the the Onyx BookKeeper replication is striped to 3 BookKeeper<br />
instances (the quorum), and written to 3 instances (the ensemble).</p>

<h4 id="running-the-embedded-bookkeeper-server">Running the embedded BookKeeper server</h4>

<p>The embedded BookKeeper server can be started via the <code>onyx.api/start-env</code> api<br />
call, with an env-config where <code>:onyx.bookkeeper/server?</code> is <code>true</code>.</p>

<p>When running on a single node, you may wish to use BookKeeper without starting<br />
the multiple instances of BookKeeper required to meet the ensemble and quorum<br />
requirements. In this case you may start a local quorum (3) of BookKeeper<br />
servers by setting <code>:onyx.bookkeeper/local-quorum?</code> to <code>true</code>.</p>

<h5 id="embedded-bookkeeper-configuration-parameters">Embedded BookKeeper Configuration Parameters</h5>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>:onyx.bookkeeper/server?</code></td>
      <td>Bool to denote whether to startup a BookKeeper instance on this node, for use in persisting Onyx state information.</td>
      <td>false</td>
    </tr>
    <tr>
      <td><code>:onyx.bookkeeper/base-ledger-dir</code></td>
      <td>Directory to store BookKeeper’s ledger in. It is recommended that this is altered to somewhere fast, preferably on a different disk to the BookKeeper journal</td>
      <td>/tmp/bookkeeper_ledger</td>
    </tr>
    <tr>
      <td><code>:onyx.bookkeeper/port</code></td>
      <td>Port to startup this node’s BookKeeper instance on.</td>
      <td>3196</td>
    </tr>
    <tr>
      <td><code>:onyx.bookkeeper/local-quorum-ports</code></td>
      <td>Ports to use for the local BookKeeper quorum.</td>
      <td>[3196 3197 3198]</td>
    </tr>
    <tr>
      <td><code>:onyx.bookkeeper/base-journal-dir</code></td>
      <td>Directory to store BookKeeper’s journal in. It is recommended that this is altered to somewhere fast, preferably on a different disk to the BookKeeper ledger.</td>
      <td>/tmp/bookkeeper_journal</td>
    </tr>
    <tr>
      <td><code>:onyx.bookkeeper/local-quorum?</code></td>
      <td>Bool to denote whether to startup a full quorum of BookKeeper instances on this node. <strong>Important: for TEST purposes only.</strong></td>
      <td>false</td>
    </tr>
  </tbody>
</table>

<h4 id="state-log-compaction">State Log Compaction</h4>

<p>It is recommended that the state changelog is periodically compacted. When<br />
compaction occurs, the current state is written to a new ledger and all<br />
previous ledgers are swapped for the new compacted state ledger.</p>

<p>Compaction can currently only be performed within a task lifecycle for the<br />
windowed task. Be careful to choose the condition (see <code>YOUR-CONDITION</code> in the<br />
example below, as compacting too often is likely expensive. Compacting once<br />
every X segments is reasonable good choice of condition.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>(<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">compaction-lifecycle</span>
    {<span style="color:#A60">:lifecycle/before-batch</span> 
     (<span style="color:#080;font-weight:bold">fn</span> [event lifecycle]
      (<span style="color:#080;font-weight:bold">when</span> YOUR-CONDITION
        (state-extensions/compact-log (<span style="color:#A60">:onyx.core/state-log</span> event) event @(<span style="color:#A60">:onyx.core/window-state</span> event)))
      {})})
</pre></div>
</div>
</div>

<h4 id="bookkeeper-implementation-configuration">BookKeeper Implementation Configuration</h4>

<p>The BookKeeper state log implementation can be configured via the peer-config.<br />
Of particular note, is <code>:onyx.bookkeeper/ledger-password</code> which generally be<br />
changed to a more secure default.</p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>:onyx.bookkeeper/read-batch-size</code></td>
      <td>Number of bookkeeper ledger entries to read at a time when recovering state. Effective batch read of state entries is write-batch-size * read-batch-size.</td>
      <td>50</td>
    </tr>
    <tr>
      <td><code>:onyx.bookkeeper/ledger-id-written-back-off</code></td>
      <td>Number of milliseconds to back off (sleep) after writing BookKeeper ledger id to the replica.</td>
      <td>50</td>
    </tr>
    <tr>
      <td><code>:onyx.bookkeeper/ledger-password</code></td>
      <td>Password to use for Onyx state persisted to BookKeeper ledgers. Highly recommended this is changed on cluster wide basis.</td>
      <td>INSECUREDEFAULTPASSWORD</td>
    </tr>
    <tr>
      <td><code>:onyx.bookkeeper/client-throttle</code></td>
      <td>Tunable write throttle for BookKeeper ledgers.</td>
      <td>30000</td>
    </tr>
    <tr>
      <td><code>:onyx.bookkeeper/write-buffer-size</code></td>
      <td>Size of the buffer to which BookKeeper ledger writes are buffered via.</td>
      <td>10000</td>
    </tr>
    <tr>
      <td><code>:onyx.bookkeeper/client-timeout</code></td>
      <td>BookKeeper client timeout.</td>
      <td>60000</td>
    </tr>
    <tr>
      <td><code>:onyx.bookkeeper/write-batch-size</code></td>
      <td>Number of state persistence writes to batch into a single BookKeeper ledger entry.</td>
      <td>20</td>
    </tr>
    <tr>
      <td><code>:onyx.bookkeeper/ledger-quorum-size</code></td>
      <td>The number of BookKeeper instances over which entries will be written to. For example, if you have an ledger-ensemble-size of 3, and a ledger-quorum-size of 2, the first write will be written to server1 and server2, the second write will be written to server2, and server3, etc.</td>
      <td>3</td>
    </tr>
    <tr>
      <td><code>:onyx.bookkeeper/ledger-ensemble-size</code></td>
      <td>The number of BookKeeper instances over which entries will be striped. For example, if you have an ledger-ensemble-size of 3, and a ledger-quorum-size of 2, the first write will be written to server1 and server2, the second write will be written to server2, and server3, etc.</td>
      <td>3</td>
    </tr>
    <tr>
      <td><code>:onyx.bookkeeper/write-batch-timeout</code></td>
      <td>Maximum amount of time to wait while batching BookKeeper writes, before writing the batch to BookKeeper. In case of a full batch read, timeout will not be hit.</td>
      <td>50</td>
    </tr>
  </tbody>
</table>

    </div>
  </div>
</div>


    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <small><center>Copyright © Distributed Masonry 2016</center></small>
    </div>

  </div>

</footer>

  </body>

</html>
