<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Flow Conditions</title>
  <meta name="description" content="Distributed, masterless, high performance, fault tolerant data processing
">

  <script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	  ga('create', 'UA-72807409-1', 'auto');
	  ga('send', 'pageview');
  </script>

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/lavish-bootstrap.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/cheat-sheet-style.css">
  <link rel="canonical" href="http://www.onyxplatform.org/docs/user-guide/0.8.8/flow-conditions.html">
  <link rel="alternate" type="application/rss+xml" title="Onyx" href="http://www.onyxplatform.org/feed.xml" />
</head>



  <body>
    <header class="site-header">
  <div class="container-fluid">
    <div class="row">
      <div class="col-md-2"></div>
      <div class="col-md-1">
        <h2><a id="nav-title" href="/">Onyx</a></h2>
      </div>
      <div class="col-md-1"></div>
      <div class="col-md-6">
        <ul class="nav nav-pills navbar-right">
          <li class="nav-choice" role="presentation"><a href="/learn">learn</a></li>
          <li class="nav-choice" role="presentation"><a href="/docs">docs</a></li>
          <li class="nav-choice" role="presentation"><a href="/tools">tools</a></li>
          <li class="nav-choice" role="presentation"><a href="/blog">blog</a></li>
          <li class="nav-choice" role="presentation"><a href="https://github.com/onyx-platform/onyx">github</a></li>
          <li class="nav-choice" role="presentation"><a href="/support">support</a></li>
          <li class="nav-choice" role="presentation"><a href="/team">team</a></li>
        </ul>
      </div>
      <div class="col-md-2"></div>
    </div>
  </div>
</header>

    <div class="container-fluid">
  <div class="row">
    <div class="col-md-2 panel page-contents">
      <h4>Contents</h4>
      <ul>
  <li><a href="/docs/cheat-sheet/0.8.8">cheat sheet</a></li>
  <li><a href="/docs/api/0.8.8">api docs</a></li>
  <li>user guide</li>
  <ul>
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/0.8.8/aggregation-state-management.html">Aggregation and State</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/0.8.8/apis.html">APIs</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/0.8.8/architecture-low-level-design.html">Architecture</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/0.8.8/backpressure.html">Backpressure</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/0.8.8/concepts.html">Concepts</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/0.8.8/core-async-plugin.html">core.async Plugin</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/0.8.8/deployment.html">Deployment</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/0.8.8/environment.html">Environment</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/0.8.8/examples.html">Examples</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/0.8.8/faq.html">FAQ</a></li>
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/0.8.8/flow-conditions.html">Flow Conditions</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/0.8.8/functions.html">Functions</a></li>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/0.8.8/information-model.html">Information Model</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/0.8.8/lifecycles.html">Lifecycles</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/0.8.8/logging.html">Logging</a></li>
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/0.8.8/messaging.html">Messaging</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/0.8.8/monitoring.html">Monitoring</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/0.8.8/peer-config.html">Peer Configuration</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/0.8.8/performance-tuning.html">Performance Tuning</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/0.8.8/plugins.html">Plugins</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/0.8.8/production-check-list.html">Production Checklist</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/0.8.8/scheduling.html">Scheduling</a></li>
    
    
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/0.8.8/subscription.html">Subscription</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/0.8.8/testing-onyx-jobs.html">Testing Onyx Jobs</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/0.8.8/triggers.html">Triggers</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/0.8.8/what-does-it-offer.html">What does it Offer?</a></li>
    
    
    
    <li class="docs-section"><a href="/docs/user-guide/0.8.8/windowing.html">Windowing</a></li>
    
    
  </ul>
</ul>

    </div>
    <div class="col-md-1"></div>
    <div class="col-md-7 panel">
      <h2 id="flow-conditions">Flow Conditions</h2>

<p>This section covers flow conditions. Flow conditions are used for isolating logic about whether or not segments should pass through different tasks in a workflow, and support a rich degree of composition with runtime parameterization.</p>

<h3 id="summary">Summary</h3>

<p>Workflows specify the structure of your computation as a directed, acyclic graph. A workflow describes all <em>possible</em> routes that a segment can take as it enters your workflow. On the other hand, we often have the need to specify how an <em>individual</em> segment moves throughout your workflow. Many times, a segment conditionally moves from one task to another. This is a concept that Onyx takes apart and turns into its own idea, independent of the rest of your computation. They&#39;re called Flow Conditions. It should be mentioned straight away that Flow Conditions are entirely optional, and your program can ignore them entirely if you&#39;d like. Omitting them leads to the default behavior, which sends a segment to all immediate downstream tasks.</p>

<h3 id="motivating-example">Motivating Example</h3>

<p>The easiest way to learn how to use flow conditions is to see an example. Suppose we have the following workflow snippet:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">[[</span><span class="ss">:input-stream</span> <span class="ss">:process-children</span><span class="p">]</span>
 <span class="p">[</span><span class="ss">:input-stream</span> <span class="ss">:process-adults</span><span class="p">]</span>
 <span class="p">[</span><span class="ss">:input-stream</span> <span class="ss">:process-female-athletes</span><span class="p">]</span>
 <span class="p">[</span><span class="ss">:input-stream</span> <span class="ss">:process-everyone</span><span class="p">]</span>
 <span class="nv">...</span><span class="p">]</span>
</code></pre></div>
<p>This workflow takes some input in (presumably a stream of people), and directs segments to four possible tasks - <code>:process-children</code>, <code>:process-adults</code>, <code>:process-female-athletes</code>, and <code>:process-everyone</code>. Suppose we want to <em>conditionally</em> direct a segment to zero or more of these tasks, depending on some predicates. We use flow conditions to carry out this work. Flow conditions are their own data structure that are bundled along with the workflow and catalog to <code>onyx.api/submit-job</code> (with key <code>:flow-conditions</code>). Here&#39;s an example of what a flow conditions data structure would look like for our proposed workflow:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">[{</span><span class="ss">:flow/from</span> <span class="ss">:input-stream</span>
  <span class="ss">:flow/to</span> <span class="p">[</span><span class="ss">:process-children</span><span class="p">]</span>
  <span class="ss">:my/max-child-age</span> <span class="mi">17</span>
  <span class="ss">:flow/predicate</span> <span class="p">[</span><span class="ss">:my.ns/child?</span> <span class="ss">:my/max-child-age</span><span class="p">]</span>
  <span class="ss">:flow/doc</span> <span class="s">&quot;Emits segment if this segment is a child.&quot;</span><span class="p">}</span>

 <span class="p">{</span><span class="ss">:flow/from</span> <span class="ss">:input-stream</span>
  <span class="ss">:flow/to</span> <span class="p">[</span><span class="ss">:process-adults</span><span class="p">]</span>
  <span class="ss">:flow/predicate</span> <span class="ss">:my.ns/adult?</span>
  <span class="ss">:flow/doc</span> <span class="s">&quot;Emits segment if this segment is an adult.&quot;</span><span class="p">}</span>

 <span class="p">{</span><span class="ss">:flow/from</span> <span class="ss">:input-stream</span>
  <span class="ss">:flow/to</span> <span class="p">[</span><span class="ss">:process-female-athletes</span><span class="p">]</span>
  <span class="ss">:flow/predicate</span> <span class="p">[</span><span class="ss">:and</span> <span class="ss">:my.ns/female?</span> <span class="ss">:my.ns/athlete?</span><span class="p">]</span>
  <span class="ss">:flow/doc</span> <span class="s">&quot;Emits segment if this segment is a female athlete.&quot;</span><span class="p">}</span>

 <span class="p">{</span><span class="ss">:flow/from</span> <span class="ss">:input-stream</span>
  <span class="ss">:flow/to</span> <span class="p">[</span><span class="ss">:process-everyone</span><span class="p">]</span>
  <span class="ss">:flow/predicate</span> <span class="ss">:my.ns/constantly-true</span>
  <span class="ss">:flow/doc</span> <span class="s">&quot;Always emit this segment&quot;</span><span class="p">}]</span>
</code></pre></div>
<p>The basic idea is that every entry in the Flow Conditions data structure denotes a relationship between a task and its downstream tasks. <code>:flow/from</code> indicates the task that the segment is leaving, and <code>:flow/to</code> indicates the tasks that the segment should be sent to if the predicate evaluates to true. The predicate is denoted by <code>:flow/predicate</code>, which is a keyword or sequence of keywords that are resolved to a function. Later in this section, we&#39;ll cover how exactly the predicate function is constructed.</p>

<p>There is <em>one</em> flow conditions data structure per job - that is, there is one vector of maps. The order that you specify the flow conditions in matters. More on that later in this section.</p>

<p>Example project: <a href="https://github.com/onyx-platform/onyx-examples/tree/0.8.x/flow-combine">flow-combine</a></p>

<h3 id="predicate-function-signatures">Predicate Function Signatures</h3>

<p>A predicate function is a Clojure function that takes at least four parameters - a context map, the old segment, the new segment, and the collection of all new segments produced from the old segment. Predicates can take parameters at runtime. They will be appended to the end of the function invocation. See Predicate Parameters for further discussion of how to use runtime parameters.</p>

<p>Predicates for the above examples can be seen below:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">child?</span> <span class="p">[</span><span class="nv">event</span> <span class="nv">old-segment</span> <span class="nv">new-segment</span> <span class="nv">all-new</span> <span class="nv">max-age</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">&lt;= </span><span class="p">(</span><span class="ss">:age</span> <span class="nv">new-segment</span><span class="p">)</span> <span class="nv">max-age</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">adult?</span> <span class="p">[</span><span class="nv">event</span> <span class="nv">old-segment</span> <span class="nv">new-segment</span> <span class="nv">all-new</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">&gt;= </span><span class="p">(</span><span class="ss">:age</span> <span class="nv">new-segment</span><span class="p">)</span> <span class="mi">18</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">female?</span> <span class="p">[</span><span class="nv">event</span> <span class="nv">old-segment</span> <span class="nv">new-segment</span> <span class="nv">all-new</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="ss">:gender</span> <span class="nv">new-segment</span><span class="p">)</span> <span class="s">&quot;Female&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">athlete?</span> <span class="p">[</span><span class="nv">event</span> <span class="nv">old-segment</span> <span class="nv">new-segment</span> <span class="nv">all-new</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="ss">:job</span> <span class="nv">new-segment</span><span class="p">)</span> <span class="s">&quot;athlete&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">constantly-true</span> <span class="p">(</span><span class="nb">constantly </span><span class="nv">true</span><span class="p">))</span>
</code></pre></div>
<h3 id="predicate-parameters">Predicate Parameters</h3>

<p>Predicate functions can take parameters at runtime. In this first flow condition, we use the parameter <code>:my/max-child-age</code> and set its value to <code>17</code>. We pass this value to the predicate by surrounding it with brackets, as in: <code>[:my.ns/child? :my/max-child-age]</code>. The parameters are appended to the end of the function call to the predicate. See Predicate Function Signatures in this section to see the arguments that are passed into the predicate regardless each invocation.</p>

<h3 id="key-exclusion">Key Exclusion</h3>

<p>Sometimes, the decision of whether to allow a segment to pass through to the next task depends on some side effects that were a result of the original segment transformation. Onyx allows you to handle this case by adding extra keys to your segment that comes out of the transformation function. These extra keys are visible in your predicate function, and then stripped off before being sent to the next task. You can indicate these &quot;extra keys&quot; by the setting <code>:onyx/exclude-keys</code> to a vector of keys.</p>

<p>For example, if we had the following transformation function:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">my-function</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">assoc </span><span class="nv">x</span> <span class="ss">:result</span> <span class="mi">42</span> <span class="ss">:side-effects-result</span> <span class="ss">:blah</span><span class="p">))</span>
</code></pre></div>
<p>Our predicate for flow conditions might need to use the <code>:side-effects-result</code> to make a decision. We don&#39;t want to actually send that information over out to the next task, though - so we <code>:flow/exclude-keys</code> on <code>:side-effects-results</code> to make it disappear after the predicate result has been realized.</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">{</span><span class="ss">:flow/from</span> <span class="ss">:input-stream</span>
 <span class="ss">:flow/to</span> <span class="p">[</span><span class="ss">:process-adults</span><span class="p">]</span>
 <span class="ss">:flow/predicate</span> <span class="ss">:my.ns/adult?</span>
 <span class="ss">:flow/exclude-keys</span> <span class="p">[</span><span class="ss">:side-effects-result</span><span class="p">]</span>
 <span class="ss">:flow/doc</span> <span class="s">&quot;Emits segment if this segment is an adult.&quot;</span><span class="p">}</span>
</code></pre></div>
<p>Example project: <a href="https://github.com/onyx-platform/onyx-examples/tree/0.8.x/flow-exclude-keys">flow-exclude-keys</a></p>

<h3 id="predicate-composition">Predicate Composition</h3>

<p>One extraordinarily powerful feature of Flow Conditions is its composition characteristics. Predicates can be composed with logical <code>and</code>, <code>or</code>, and <code>not</code>. We use composition to check if the segment is both female and an athlete in <code>[:and :my.ns/female? :my.ns/athlete?]</code>. Logical function calls must be surrounded with brackets, and may be nested arbitrarily. Functions inside of logical operator calls may be parameterized, as in <code>[:and :my.ns/female? [:my.ns/athlete? :my/state-param]]</code> Parameters <em>may not</em> specify logical functions.</p>

<p>Example project: <a href="https://github.com/onyx-platform/onyx-examples/tree/0.8.x/flow-predicate-composition">flow-predicate-composition</a></p>

<h3 id="match-all/none">Match All/None</h3>

<p>Sometimes, you want a flow condition that emits a value to all tasks if the predicate is true. You can use short hand to emit to all downstream tasks:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">{</span><span class="ss">:flow/from</span> <span class="ss">:input-stream</span>
 <span class="ss">:flow/to</span> <span class="ss">:all</span>
 <span class="ss">:flow/short-circuit?</span> <span class="nv">true</span>
 <span class="ss">:flow/predicate</span> <span class="ss">:my.ns/adult?</span><span class="p">}</span>
</code></pre></div>
<p>Similarly, sometimes you want to emit to no downstream tasks:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">{</span><span class="ss">:flow/from</span> <span class="ss">:input-stream</span>
 <span class="ss">:flow/to</span> <span class="ss">:none</span>
 <span class="ss">:flow/short-circuit?</span> <span class="nv">true</span>
 <span class="ss">:flow/predicate</span> <span class="ss">:my.ns/adult?</span><span class="p">}</span>
</code></pre></div>
<p>If a flow condition specifies <code>:all</code> as its <code>:flow/to</code>, it must come before any other flow conditions. If a flow condition specifies <code>:none</code> as its <code>:flow/to</code>, it must come directly behind an <code>:all</code> condition, or first if there is no <code>:all</code> condition. This is because of the semantics of short circuiting. We&#39;ll discuss what short circuiting means later in this section.</p>

<p><code>:flow/to</code> set to <code>:all</code> or <code>:none</code> must always set <code>:flow/short-circuit?</code> to <code>true</code>.</p>

<p><code>:flow/from</code> may be set to <code>:all</code>. This directs all immediate upstream links to pass segments to this task&#39;s flow condition. <code>:flow/from</code> as <code>:all</code> does not impose order constraints as <code>:flow/to</code> set to <code>:all</code> does.</p>

<h3 id="short-circuiting">Short Circuiting</h3>

<p>If multiple flow condition entries evaluate to a true predicate, their <code>:flow/to</code> values are unioned (duplicates aren&#39;t acknowledged), as well as their <code>:flow/exclude-keys</code>. Sometimes you don&#39;t want this behavior, and you want to specify exactly the downstream tasks to emit to - and not check any more flow condition entries. You can do this with <code>:flow/short-circuit?</code> set to <code>true</code>. Any entry that has <code>:flow/short-circuit?</code> set to <code>true</code> must come before any entries for an task that have it set to <code>false</code> or <code>nil</code>.</p>

<p>Example project: <a href="https://github.com/onyx-platform/onyx-examples/tree/0.8.x/flow-short-circuit">flow-short-circuit</a></p>

<h3 id="exceptions">Exceptions</h3>

<p>Flow Conditions give you leverage for handling exceptions without miring your code in <code>try</code>/<code>catch</code> logic. If an exception is thrown from an Onyx transformation function, you can capture it from within your flow conditions by setting <code>:flow/thrown-exception?</code> to <code>true</code>. It&#39;s default value is <code>false</code>. If an exception is thrown, only flow conditions with <code>:flow/thrown-exception?</code> set to <code>true</code> will be evaluated. The value that is normally the segment which is sent to the predicate will be the exception object that was thrown. Exception flow conditions must have <code>:flow/short-circuit?</code> set to <code>true</code>. Note that exceptions don&#39;t serialize. This feature is meant to be used in conjunction with Post-transformations and Actions for sending exception values to downstream tasks.</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">{</span><span class="ss">:flow/from</span> <span class="ss">:input-stream</span>
 <span class="ss">:flow/to</span> <span class="p">[</span><span class="ss">:error-task</span><span class="p">]</span>
 <span class="ss">:flow/short-circuit?</span> <span class="nv">true</span>
 <span class="ss">:flow/thrown-exception?</span> <span class="nv">true</span>
 <span class="ss">:flow/predicate</span> <span class="ss">:my.ns/handle-error?</span><span class="p">}</span>
</code></pre></div>
<p>And the predicate might be:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">handle-error?</span> <span class="p">[</span><span class="nv">event</span> <span class="nv">old</span> <span class="nv">ex-obj</span> <span class="nv">all-new</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">type</span> <span class="nv">ex-obj</span><span class="p">)</span> <span class="nv">java.lang.NullPointerException</span><span class="p">))</span>
</code></pre></div>
<p>This will only restrict the flow from <code>:input-stream</code> to <code>:error-task</code> when an exception is thrown - see the discussion of Short Circuiting above. When an
exception is not thrown, the default behaviour will apply. For example, if there are later flow conditions, they will apply. If not will flow through to
all tasks if there are no other flow conditions for that task.</p>

<h3 id="post-transform">Post-transform</h3>

<p>Post-transformations are extension provided to handle segments that cause exceptions to arise. If a flow condition has <code>:flow/thrown-exception?</code> set to <code>true</code>, it can also set <code>:flow/post-transform</code> to a keyword. This keyword must have the value of a fully namespace qualified function on the classpath. This function will be invoked with three parameters: the event map, the segment that caused the exception, and the exception object. The result of this function, which must be a segment, will be passed to the downstream tasks. This allows you to come up with a reasonable value to pass downstream when you encounter an exception, since exceptions don&#39;t serialize anyway. <code>:flow/exclude-keys</code> will be called on the resulting transformed segment.</p>

<p>Example:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">{</span><span class="ss">:flow/from</span> <span class="ss">:input-stream</span>
 <span class="ss">:flow/to</span> <span class="p">[</span><span class="ss">:error-task</span><span class="p">]</span>
 <span class="ss">:flow/short-circuit?</span> <span class="nv">true</span>
 <span class="ss">:flow/thrown-exception?</span> <span class="nv">true</span>
 <span class="ss">:flow/post-transform</span> <span class="ss">:my.ns/post-transform</span>
 <span class="ss">:flow/predicate</span> <span class="ss">:my.ns/handle-error?</span><span class="p">}</span>
</code></pre></div>
<p>And an example post-transform function might be:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">post-transform</span> <span class="p">[</span><span class="nv">event</span> <span class="nv">segment</span> <span class="nv">exception-obj</span><span class="p">]</span>
  <span class="p">{</span><span class="ss">:error</span> <span class="ss">:my-exception-value</span><span class="p">})</span>
</code></pre></div>
<h3 id="actions">Actions</h3>

<p>After a set of flow conditions has been evaluated for a segment, you usually want to send the segment downstream to the next set of tasks. Other times, you want to retry to process the segment because something went wrong. Perhaps a database connection wasn&#39;t available, or an email couldn&#39;t be sent.</p>

<p>Onyx provides Flow Conditions <code>:flow/action</code> to accomplish this. By setting <code>:flow/action</code> to <code>:retry</code>, a segment will expire from the internal pool of pending messages and be automatically retried from its input task. If any of the <code>:flow/action</code>s from the matching flow conditions are <code>:retry</code>, the segment will be retried and <em>will not</em> be sent downstream. This parameter is optional, and it&#39;s default value is <code>nil</code>. <code>nil</code> will cause the segment to be sent to all downstream tasks that were selected from evaluating the flow conditions. Any flow condition clauses with <code>:flow/action</code> set to <code>:retry</code> must also have <code>:flow/short-circuit?</code> set to <code>true</code>, and <code>:flow/to</code> set to <code>:none</code>.</p>

<p>Here&#39;s a quick example:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">[{</span><span class="ss">:flow/from</span> <span class="ss">:input-stream</span>
  <span class="ss">:flow/to</span> <span class="ss">:none</span>
  <span class="ss">:flow/short-circuit?</span> <span class="nv">true</span>
  <span class="ss">:flow/predicate</span> <span class="ss">:my.ns/adult?</span>
  <span class="ss">:flow/action</span> <span class="ss">:retry</span><span class="p">}</span>

 <span class="p">{</span><span class="ss">:flow/from</span> <span class="ss">:input-stream</span>
  <span class="ss">:flow/to</span> <span class="p">[</span><span class="ss">:task-a</span><span class="p">]</span>
  <span class="ss">:flow/predicate</span> <span class="ss">:my.ns/child?</span><span class="p">}]</span>
</code></pre></div>
    </div>
  </div>
</div>


    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <small><center>Copyright © Distributed Masonry 2016</center></small>
    </div>

  </div>

</footer>

  </body>

</html>
